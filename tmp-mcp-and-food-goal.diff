diff --git a/AGENTS.md b/AGENTS.md
index e3bad39..9ff880c 100644
--- a/AGENTS.md
+++ b/AGENTS.md
@@ -3,7 +3,9 @@
 ## Repository Layout
 - `workflows/` - Temporal workflows including the main AgentGoalWorkflow for multi-turn AI conversations
 - `activities/` - Temporal activities for tool execution and LLM interactions  
-- `tools/` - AI agent tools organized by category (finance, HR, ecommerce, travel, etc.)
+- `tools/` - Native AI agent tool implementations organized by category (finance, HR, ecommerce, travel, etc.)
+- `goals/` - Agent goal definitions organized by category, supporting both native and MCP tools
+- `shared/` - Shared configuration including MCP server definitions
 - `models/` - Data types and tool definitions used throughout the system
 - `prompts/` - Agent prompt generators and templates
 - `api/` - FastAPI server that exposes REST endpoints to interact with workflows
@@ -136,29 +138,48 @@ poetry run mypy --check-untyped-defs --namespace-packages .
 
 ## Agent Customization
 
-### Adding New Tools
+### Adding New Goals and Tools
+
+#### For Native Tools:
 1. Create tool implementation in `tools/` directory
 2. Add tool function mapping in `tools/__init__.py`  
 3. Register tool definition in `tools/tool_registry.py`
-4. Associate with goals in `tools/goal_registry.py`
+4. Add tool names to static tools list in `workflows/workflow_helpers.py`
+5. Create or update goal definition in appropriate file in `goals/` directory
+
+#### For MCP Tools:
+1. Configure MCP server definition in `shared/mcp_config.py` (for reusable servers)
+2. Create or update goal definition in appropriate file in `goals/` directory with `mcp_server_definition`
+3. Set required environment variables (API keys, etc.)
+
+#### For Goals:
+1. Create goal file in `goals/` directory (e.g., `goals/my_category.py`)
+2. Import and extend the goal list in `goals/__init__.py`
 
 ### Configuring Goals
-The agent supports multiple goal categories:
-- **Financial**: Money transfers, loan applications (`fin/`)
-- **HR**: PTO booking, payroll status (`hr/`)  
-- **Travel**: Flight/train booking, event finding
-- **Ecommerce**: Order tracking, package management (`ecommerce/`)
+The agent supports multiple goal categories organized in `goals/`:
+- **Financial**: Money transfers, loan applications (`goals/finance.py`)
+- **HR**: PTO booking, payroll status (`goals/hr.py`)  
+- **Travel**: Flight/train booking, event finding (`goals/travel.py`)
+- **Ecommerce**: Order tracking, package management (`goals/ecommerce.py`)
+- **Food**: Restaurant ordering and cart management (`goals/food.py`)
+- **MCP Integrations**: External service integrations like Stripe (`goals/stripe_mcp.py`)
+
+Goals can use:
+- **Native Tools**: Custom implementations in `/tools/` directory
+- **MCP Tools**: External tools via Model Context Protocol servers (configured in `shared/mcp_config.py`)
 
 See [adding-goals-and-tools.md](adding-goals-and-tools.md) for detailed customization guide.
 
 ## Architecture
 
 This system implements "Agentic AI" with these key components:
-1. **Goals** - High-level objectives accomplished through tool sequences
-2. **Agent Loops** - LLM execution → tool calls → human input → repeat until goal completion
-3. **Tool Approval** - Human confirmation for sensitive operations
-4. **Conversation Management** - LLM-powered input validation and history summarization
-5. **Durability** - Temporal workflows ensure reliable execution across failures
+1. **Goals** - High-level objectives accomplished through tool sequences (organized in `/goals/` by category)
+2. **Native & MCP Tools** - Custom implementations and external service integrations
+3. **Agent Loops** - LLM execution → tool calls → human input → repeat until goal completion
+4. **Tool Approval** - Human confirmation for sensitive operations
+5. **Conversation Management** - LLM-powered input validation and history summarization
+6. **Durability** - Temporal workflows ensure reliable execution across failures
 
 For detailed architecture information, see [architecture.md](architecture.md).
 
diff --git a/README.md b/README.md
index 2414612..f6eb793 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,12 @@
 # Temporal AI Agent
 
-This demo shows a multi-turn conversation with an AI agent running inside a Temporal workflow. The purpose of the agent is to collect information towards a goal, running tools along the way. There's a simple DSL input for collecting information (currently set up to use mock functions to search for public events, search for flights around those events, then create a test Stripe invoice for the trip).
+This demo shows a multi-turn conversation with an AI agent running inside a Temporal workflow. The purpose of the agent is to collect information towards a goal, running tools along the way. 
+
+The system supports two types of tools:
+- **Native Tools**: Custom tools implemented directly in the codebase (in `/tools/`)
+- **MCP Tools**: External tools accessed via Model Context Protocol (MCP) servers like Stripe, databases, or APIs
+
+Goals are organized in the `/goals/` directory by category (finance, HR, travel, ecommerce, etc.) and can leverage both native and MCP tools.
 
 The AI will respond with clarifications and ask for any missing information to that goal. You can configure it to use any LLM supported by [LiteLLM](https://docs.litellm.ai/docs/providers), including:
 - OpenAI models (GPT-4, GPT-3.5)
@@ -41,7 +47,9 @@ LLM_KEY=your-api-key-here
 ```
 
 ## Customizing Interaction & Tools
-See [the guide to adding goals and tools](./adding-goals-and-tools.md).
+See [the guide to adding goals and tools](./adding-goals-and-tools.md). 
+
+The system supports MCP (Model Context Protocol) for easy integration with external services. MCP server configurations are managed in `shared/mcp_config.py`, and goals are organized by category in the `/goals/` directory.
 
 ## Architecture
 See [the architecture guide](./architecture.md).
diff --git a/activities/tool_activities.py b/activities/tool_activities.py
index 22254b5..6752b10 100644
--- a/activities/tool_activities.py
+++ b/activities/tool_activities.py
@@ -1,13 +1,15 @@
 import inspect
 import json
 import os
+from contextlib import asynccontextmanager
 from datetime import datetime
-from typing import Sequence
+from typing import Any, Dict, List, Optional, Sequence
 
 from dotenv import load_dotenv
 from litellm import completion
 from temporalio import activity
 from temporalio.common import RawValue
+from temporalio.exceptions import ApplicationError
 
 from models.data_types import (
     EnvLookupInput,
@@ -16,6 +18,17 @@ from models.data_types import (
     ValidationInput,
     ValidationResult,
 )
+from models.tool_definitions import MCPServerDefinition
+
+# Import MCP client libraries
+try:
+    from mcp import ClientSession, StdioServerParameters
+    from mcp.client.stdio import stdio_client
+except ImportError:
+    # Fallback if MCP not installed
+    ClientSession = None
+    StdioServerParameters = None
+    stdio_client = None
 
 load_dotenv(override=True)
 
@@ -120,10 +133,14 @@ class ToolActivities:
             response = completion(**completion_kwargs)
 
             response_content = response.choices[0].message.content
-            activity.logger.info(f"LLM response: {response_content}")
+            activity.logger.info(f"Raw LLM response: {repr(response_content)}")
+            activity.logger.info(f"LLM response content: {response_content}")
+            activity.logger.info(f"LLM response type: {type(response_content)}")
+            activity.logger.info(f"LLM response length: {len(response_content) if response_content else 'None'}")
 
             # Use the new sanitize function
             response_content = self.sanitize_json_response(response_content)
+            activity.logger.info(f"Sanitized response: {repr(response_content)}")
 
             return self.parse_json_response(response_content)
         except Exception as e:
@@ -182,6 +199,79 @@ class ToolActivities:
 
         return output
 
+    @activity.defn
+    async def mcp_tool_activity(
+        self, tool_name: str, tool_args: Dict[str, Any]
+    ) -> Dict[str, Any]:
+        """MCP Tool"""
+        activity.logger.info(f"Executing MCP tool: {tool_name} with args: {tool_args}")
+
+        # Extract server definition and convert argument types
+        server_definition = tool_args.pop("server_definition", None)
+        converted_args = _convert_args_types(tool_args)
+        connection = _build_connection(server_definition)
+
+        try:
+            if connection["type"] == "stdio":
+                # Handle stdio connection
+                async with _stdio_connection(
+                    command=connection.get("command", "python"),
+                    args=connection.get("args", ["server.py"]),
+                    env=connection.get("env", {}),
+                ) as (read, write):
+                    async with ClientSession(read, write) as session:
+                        # Initialize the session
+                        activity.logger.info(f"Initializing MCP session for {tool_name}")
+                        await session.initialize()
+                        activity.logger.info(f"MCP session initialized for {tool_name}")
+
+                        # Call the tool
+                        activity.logger.info(f"Calling MCP tool {tool_name} with args: {converted_args}")
+                        try:
+                            result = await session.call_tool(tool_name, arguments=converted_args)
+                            activity.logger.info(f"MCP tool {tool_name} returned result: {result}")
+                        except Exception as tool_exc:
+                            activity.logger.error(f"MCP tool {tool_name} call failed: {type(tool_exc).__name__}: {tool_exc}")
+                            raise
+
+                        normalized_result = _normalize_result(result)
+                        activity.logger.info(f"Tool {tool_name} completed successfully")
+
+                        return {
+                            "tool": tool_name,
+                            "success": True,
+                            "content": normalized_result,
+                        }
+
+            elif connection["type"] == "tcp":
+                # Handle TCP connection (placeholder for future implementation)
+                raise ApplicationError("TCP connections not yet implemented")
+
+            else:
+                raise ApplicationError(
+                    f"Unsupported connection type: {connection['type']}"
+                )
+
+        except Exception as e:
+            # Handle ExceptionGroup specifically (Python 3.11+ async errors)
+            if hasattr(e, 'exceptions'):
+                # This is an ExceptionGroup - log all sub-exceptions
+                activity.logger.error(f"MCP tool {tool_name} failed with ExceptionGroup:")
+                for i, sub_exc in enumerate(e.exceptions):
+                    activity.logger.error(f"  Sub-exception {i}: {type(sub_exc).__name__}: {sub_exc}")
+                error_msg = f"Multiple errors: {'; '.join(str(ex) for ex in e.exceptions)}"
+            else:
+                activity.logger.error(f"MCP tool {tool_name} failed: {type(e).__name__}: {str(e)}")
+                error_msg = str(e)
+
+            # Return error information
+            return {
+                "tool": tool_name,
+                "success": False,
+                "error": error_msg,
+                "error_type": type(e).__name__,
+            }
+
 
 @activity.defn(dynamic=True)
 async def dynamic_tool_activity(args: Sequence[RawValue]) -> dict:
@@ -191,13 +281,232 @@ async def dynamic_tool_activity(args: Sequence[RawValue]) -> dict:
     tool_args = activity.payload_converter().from_payload(args[0].payload, dict)
     activity.logger.info(f"Running dynamic tool '{tool_name}' with args: {tool_args}")
 
-    # Delegate to the relevant function
-    handler = get_handler(tool_name)
-    if inspect.iscoroutinefunction(handler):
-        result = await handler(tool_args)
+    # Check if this is an MCP tool call by looking for server_definition in args
+    server_definition = tool_args.pop("server_definition", None)
+
+    if server_definition:
+        # This is an MCP tool call - handle it directly
+        activity.logger.info(f"Executing MCP tool: {tool_name}")
+
+        # Convert argument types for MCP tools
+        converted_args = _convert_args_types(tool_args)
+        connection = _build_connection(server_definition)
+
+        try:
+            if connection["type"] == "stdio":
+                # Handle stdio connection
+                async with _stdio_connection(
+                    command=connection.get("command", "python"),
+                    args=connection.get("args", ["server.py"]),
+                    env=connection.get("env", {}),
+                ) as (read, write):
+                    async with ClientSession(read, write) as session:
+                        # Initialize the session
+                        activity.logger.info(f"Initializing MCP session for {tool_name}")
+                        await session.initialize()
+                        activity.logger.info(f"MCP session initialized for {tool_name}")
+
+                        # Call the tool
+                        activity.logger.info(f"Calling MCP tool {tool_name} with args: {converted_args}")
+                        try:
+                            result = await session.call_tool(tool_name, arguments=converted_args)
+                            activity.logger.info(f"MCP tool {tool_name} returned result: {result}")
+                        except Exception as tool_exc:
+                            activity.logger.error(f"MCP tool {tool_name} call failed: {type(tool_exc).__name__}: {tool_exc}")
+                            raise
+
+                        normalized_result = _normalize_result(result)
+                        activity.logger.info(
+                            f"MCP tool {tool_name} completed successfully"
+                        )
+
+                        return {
+                            "tool": tool_name,
+                            "success": True,
+                            "content": normalized_result,
+                        }
+
+            elif connection["type"] == "tcp":
+                # Handle TCP connection (placeholder for future implementation)
+                raise ApplicationError("TCP connections not yet implemented")
+
+            else:
+                raise ApplicationError(
+                    f"Unsupported connection type: {connection['type']}"
+                )
+
+        except Exception as e:
+            activity.logger.error(f"MCP tool {tool_name} failed: {str(e)}")
+
+            # Return error information
+            return {
+                "tool": tool_name,
+                "success": False,
+                "error": str(e),
+                "error_type": type(e).__name__,
+            }
     else:
-        result = handler(tool_args)
+        # This is a regular tool - delegate to the relevant function
+        handler = get_handler(tool_name)
+        if inspect.iscoroutinefunction(handler):
+            result = await handler(tool_args)
+        else:
+            result = handler(tool_args)
+
+        # Optionally log or augment the result
+        activity.logger.info(f"Tool '{tool_name}' result: {result}")
+        return result
 
-    # Optionally log or augment the result
-    activity.logger.info(f"Tool '{tool_name}' result: {result}")
+
+# MCP Client Activities
+
+
+def _build_connection(
+    server_definition: MCPServerDefinition | Dict[str, Any] | None,
+) -> Dict[str, Any]:
+    """Build connection parameters from MCPServerDefinition or dict"""
+    if server_definition is None:
+        # Default to stdio connection with the main server
+        return {"type": "stdio", "command": "python", "args": ["server.py"], "env": {}}
+
+    # Handle both MCPServerDefinition objects and dicts (from Temporal serialization)
+    if isinstance(server_definition, dict):
+        return {
+            "type": server_definition.get("connection_type", "stdio"),
+            "command": server_definition.get("command", "python"),
+            "args": server_definition.get("args", ["server.py"]),
+            "env": server_definition.get("env", {}) or {},
+        }
+
+    return {
+        "type": server_definition.connection_type,
+        "command": server_definition.command,
+        "args": server_definition.args,
+        "env": server_definition.env or {},
+    }
+
+
+def _normalize_result(result: Any) -> Any:
+    """Normalize MCP tool result for serialization"""
+    if hasattr(result, "content"):
+        # Handle MCP result objects
+        if hasattr(result.content, "__iter__") and not isinstance(result.content, str):
+            return [
+                item.text if hasattr(item, "text") else str(item)
+                for item in result.content
+            ]
+        return str(result.content)
     return result
+
+
+def _convert_args_types(tool_args: Dict[str, Any]) -> Dict[str, Any]:
+    """Convert string arguments to appropriate types for MCP tools"""
+    converted_args = {}
+    
+    for key, value in tool_args.items():
+        if key == "server_definition":
+            # Skip server_definition - it's metadata
+            continue
+            
+        if isinstance(value, str):
+            # Try to convert string values to appropriate types
+            if value.isdigit():
+                # Convert numeric strings to integers
+                converted_args[key] = int(value)
+            elif value.replace('.', '').isdigit() and value.count('.') == 1:
+                # Convert decimal strings to floats
+                converted_args[key] = float(value)
+            elif value.lower() in ('true', 'false'):
+                # Convert boolean strings
+                converted_args[key] = value.lower() == 'true'
+            else:
+                # Keep as string
+                converted_args[key] = value
+        else:
+            # Keep non-string values as-is
+            converted_args[key] = value
+    
+    return converted_args
+
+
+@asynccontextmanager
+async def _stdio_connection(command: str, args: list, env: dict):
+    """Create stdio connection to MCP server"""
+    if stdio_client is None:
+        raise ApplicationError("MCP client libraries not available")
+
+    # Create server parameters
+    server_params = StdioServerParameters(command=command, args=args, env=env)
+
+    async with stdio_client(server_params) as (read, write):
+        yield read, write
+
+
+@activity.defn
+async def mcp_list_tools(
+    server_definition: MCPServerDefinition, include_tools: Optional[List[str]] = None
+) -> Dict[str, Any]:
+    """List available MCP tools from the specified server"""
+
+    activity.logger.info(f"Listing MCP tools for server: {server_definition.name}")
+
+    connection = _build_connection(server_definition)
+
+    try:
+        if connection["type"] == "stdio":
+            async with _stdio_connection(
+                command=connection.get("command", "python"),
+                args=connection.get("args", ["server.py"]),
+                env=connection.get("env", {}),
+            ) as (read, write):
+                async with ClientSession(read, write) as session:
+                    # Initialize the session
+                    await session.initialize()
+
+                    # List available tools
+                    tools_response = await session.list_tools()
+
+                    # Process tools based on include_tools filter
+                    tools_info = {}
+                    for tool in tools_response.tools:
+                        # If include_tools is specified, only include those tools
+                        if include_tools is None or tool.name in include_tools:
+                            tools_info[tool.name] = {
+                                "name": tool.name,
+                                "description": tool.description,
+                                "inputSchema": (
+                                    tool.inputSchema.model_dump()
+                                    if hasattr(tool.inputSchema, "model_dump")
+                                    else str(tool.inputSchema)
+                                ),
+                            }
+
+                    activity.logger.info(
+                        f"Found {len(tools_info)} tools for server {server_definition.name}"
+                    )
+
+                    return {
+                        "server_name": server_definition.name,
+                        "success": True,
+                        "tools": tools_info,
+                        "total_available": len(tools_response.tools),
+                        "filtered_count": len(tools_info),
+                    }
+
+        elif connection["type"] == "tcp":
+            raise ApplicationError("TCP connections not yet implemented")
+
+        else:
+            raise ApplicationError(f"Unsupported connection type: {connection['type']}")
+
+    except Exception as e:
+        activity.logger.error(
+            f"Failed to list tools for server {server_definition.name}: {str(e)}"
+        )
+
+        return {
+            "server_name": server_definition.name,
+            "success": False,
+            "error": str(e),
+            "error_type": type(e).__name__,
+        }
diff --git a/adding-goals-and-tools.md b/adding-goals-and-tools.md
index ce4c57e..3d14f41 100644
--- a/adding-goals-and-tools.md
+++ b/adding-goals-and-tools.md
@@ -1,6 +1,9 @@
 # Customizing the Agent
 The agent is set up to have multiple agents, each with their own goal. It supports switching back to choosing a new goal at the end of every successful goal (or even mid-goal). 
-A goal is made up of a list of tools that the agent will guide the user through. 
+
+A goal can use two types of tools:
+- **Native Tools**: Custom tools implemented directly in the codebase (in `/tools/`)
+- **MCP Tools**: External tools accessed via Model Context Protocol (MCP) servers
 
 It may be helpful to review the [architecture](./architecture.md) for a guide and definition of goals, tools, etc.
 
@@ -13,29 +16,35 @@ Even if you don't intend to use the goal in a multi-goal scenario, goal categori
 4. Use it in your Goal definition, see below.
 
 ## Adding a Goal
-1.  Open [/tools/goal_registry.py](tools/goal_registry.py) - this file contains descriptions of goals and the tools used to achieve them
+1. Create a new Python file in the `/goals/` directory (e.g., `goals/my_category.py`) - these files contain descriptions of goals and the tools used to achieve them
 2. Pick a name for your goal! (such as "goal_hr_schedule_pto")
 3. Fill out the required elements:
 -  `id`: needs to be the same as the name
 - `agent_name`: user-facing name for the agent/chatbot
 - `category_tag`: category for the goal
 - `agent_friendly_description`: user-facing description of what the agent/chatbot does
-- `tools`: the list of tools the goal will walk the user through. These will be defined in the [tools/tool_registry.py](tools/tool_registry.py) and should be defined in list form as tool_registry.[name of tool]
+- `tools`: the list of **native tools** the goal uses. These are defined in [tools/tool_registry.py](tools/tool_registry.py) as `tool_registry.[name_of_tool]`
 
 Example:
-```
+```python
 tools=[
     tool_registry.current_pto_tool,
     tool_registry.future_pto_calc_tool,
     tool_registry.book_pto_tool,
 ]
 ```
-- `description`: LLM-facing description of the goal that lists the tools by name and purpose.
-- `starter-prompt`: LLM-facing first prompt given to begin the scenario. This field can contain instructions that are different from other goals, like "begin by providing the output of the first tool" rather than waiting on user confirmation. (See [goal_choose_agent_type](tools/goal_registry.py) for an example.)
+- `mcp_server_definition`: (Optional) MCP server configuration for external tools. Can use predefined configurations from `shared/mcp_config.py` or define custom ones. See [MCP Tools section](#adding-mcp-tools) below.
+- `description`: LLM-facing description of the goal that lists all tools (native and MCP) by name and purpose.
+- `starter_prompt`: LLM-facing first prompt given to begin the scenario. This field can contain instructions that are different from other goals, like "begin by providing the output of the first tool" rather than waiting on user confirmation. (See [goal_choose_agent_type](tools/goal_registry.py) for an example.)
 - `example_conversation_history`: LLM-facing sample conversation/interaction regarding the goal. See the existing goals for how to structure this.
-4. Add your new goal to the `goal_list` at the bottom using `goal_list.append(your_super_sweet_new_goal)`
+4. Add your new goal to a list variable (e.g., `my_category_goals: List[AgentGoal] = [your_super_sweet_new_goal]`)
+5. Import and extend the goal list in `goals/__init__.py` by adding:
+   - Import: `from goals.my_category import my_category_goals`
+   - Extend: `goal_list.extend(my_category_goals)`
+
+## Adding Native Tools
 
-## Adding Tools
+Native tools are custom implementations that run directly in your codebase. Use these for business logic specific to your application.
 
 ### Note on Optional Tools
 Tools can be optional - you can indicate this in the tool listing of goal description (see above section re: goal registry) by adding something like, "This step is optional and can be skipped by moving to the next tool." Here is an example from an older iteration of the `goal_hr_schedule_pto` goal, when it was going to have an optional step to check for existing calendar conflicts:
@@ -58,7 +67,7 @@ Tools should generally return meaningful information and be generally ‘failsaf
 - `description`: LLM-facing description of tool
 - `arguments`: These are the _input_ arguments to the tool. Each input argument should be defined as a [ToolArgument](./models/tool_definitions.py). Tools don't have to have arguments but the arguments list has to be declared. If the tool you're creating doesn't have inputs, define arguments as `arguments=[]`
 
-### Create Each Tool
+### Create Each Native Tool Implementation
 - The tools themselves are defined in their own files in `/tools` - you can add a subfolder to organize them, see the hr tools for an example.
 - The file name and function name will be the same as each other and should also be the same as the name of the tool, without "tool" - so `current_pto_tool` would be `current_pto.py` with a function named `current_pto` within it.
 - The function should have `args: dict` as the input and also return a `dict`
@@ -66,12 +75,68 @@ Tools should generally return meaningful information and be generally ‘failsaf
 - tools are where the user input+model output becomes deterministic. Add validation here to make sure what the system is doing is valid and acceptable
 
 ### Add to `tools/__init__.py` and the tool get_handler()
-- In [tools/__init__.py](./tools/__init__.py), add an import statement for each new tool as well as an applicable return statement in `get_handler`. The tool name here should match the tool name as described in the goal's `description` field.
+- In [tools/__init__.py](./tools/__init__.py), add an import statement for each new native tool as well as an applicable return statement in `get_handler`. The tool name here should match the tool name as described in the goal's `description` field.
 Example:
-```
+```python
 if tool_name == "CurrentPTO":
     return current_pto
 ```
+
+### Update workflow_helpers.py
+- Add your new native tool to the static tools list in [workflows/workflow_helpers.py](workflows/workflow_helpers.py) so it's correctly identified as a native tool rather than an MCP tool.
+
+## Adding MCP Tools
+
+MCP (Model Context Protocol) tools are external tools provided by MCP servers. They're useful for integrating with third-party services like Stripe, databases, or APIs without implementing custom code.
+
+### Configure MCP Server Definition
+You can either use predefined MCP server configurations from `shared/mcp_config.py` or define custom ones. 
+
+#### Using Predefined Configurations
+```python
+from shared.mcp_config import get_stripe_mcp_server_definition
+
+# In your goal definition:
+mcp_server_definition=get_stripe_mcp_server_definition(included_tools=["list_products", "create_customer"])
+```
+
+#### Custom MCP Server Definition
+Add an `mcp_server_definition` to your goal:
+
+```python
+mcp_server_definition=MCPServerDefinition(
+    name="stripe-mcp",
+    command="npx",
+    args=[
+        "-y",
+        "@stripe/mcp",
+        "--tools=all",
+        f"--api-key={os.getenv('STRIPE_API_KEY')}",
+    ],
+    env=None,
+    included_tools=[
+        "list_products",
+        "list_prices", 
+        "create_customer",
+        "create_invoice",
+        "create_payment_link",
+    ],
+)
+```
+
+### MCP Tool Configuration
+- `name`: Identifier for the MCP server
+- `command`: Command to start the MCP server (e.g., "npx", "python")
+- `args`: Arguments to pass to the command
+- `env`: Environment variables for the server (optional)
+- `included_tools`: List of specific tools to use from the server (optional - if omitted, all tools are included)
+
+### How MCP Tools Work
+- MCP tools are automatically loaded when the workflow starts
+- They're dynamically converted to `ToolDefinition` objects
+- The system automatically routes MCP tool calls to the appropriate MCP server
+- No additional code implementation needed - just configuration
+
 ## Tool Confirmation
 There are three ways to manage confirmation of tool runs:
 1. Arguments confirmation box - confirm tool arguments and execution with a button click
@@ -89,12 +154,24 @@ If you really want to wait for user confirmation, record it on the workflow (as
 I recommend exploring all three. For a demo, I would decide if you want the Arguments confirmation in the UI, and if not I'd generally go with option #2 but use #3 for tools that make business sense to confirm, e.g. those tools that take action/write data.
 
 ## Add a Goal & Tools Checklist
-[  ] Add goal in [/tools/goal_registry.py](tools/goal_registry.py) <br />
-- [  ] If a new category, add Goal Category to [.env](./.env)  and [.env.example](./.env.example)  <br />
-- [  ] don't forget the goal list at the bottom of the [goal_registry.py](tools/goal_registry.py) <br />
 
-[  ] Add Tools listed in the Goal Registry to the  [tool_registry.py](tools/tool_registry.py)  <br />
-[  ] Define your tools as Activities in `/tools` <br />
-[  ] Add your tools to [tool list](tools/__init__.py) in the tool get_handler() <br />
+### For All Goals:
+- [ ] Create goal file in `/goals/` directory (e.g., `goals/my_category.py`)
+- [ ] Add goal to the category's goal list in the file
+- [ ] Import and extend the goal list in `goals/__init__.py`
+- [ ] If a new category, add Goal Category to [.env](./.env) and [.env.example](./.env.example)
+
+### For Native Tools:
+- [ ] Add native tools to [tool_registry.py](tools/tool_registry.py)
+- [ ] Implement tool functions in `/tools/` directory
+- [ ] Add tools to [tools/__init__.py](tools/__init__.py) in the `get_handler()` function
+- [ ] Add tool names to static tools list in [workflows/workflow_helpers.py](workflows/workflow_helpers.py)
+
+### For MCP Tools:
+- [ ] Add `mcp_server_definition` to your goal configuration (use `shared/mcp_config.py` for common servers)
+- [ ] Ensure MCP server is available and properly configured
+- [ ] Set required environment variables (API keys, etc.)
+- [ ] Test MCP server connectivity before running the agent
+- [ ] If creating new MCP server configs, add them to `shared/mcp_config.py` for reuse
 
 And that's it! Happy AI Agent building!
diff --git a/api/main.py b/api/main.py
index 65cf587..17850c1 100644
--- a/api/main.py
+++ b/api/main.py
@@ -11,7 +11,7 @@ from temporalio.exceptions import TemporalError
 
 from models.data_types import AgentGoalWorkflowParams, CombinedInput
 from shared.config import TEMPORAL_TASK_QUEUE, get_temporal_client
-from tools.goal_registry import goal_list
+from goals import goal_list
 from workflows.agent_goal_workflow import AgentGoalWorkflow
 
 app = FastAPI()
diff --git a/models/tool_definitions.py b/models/tool_definitions.py
index 7bdfca1..416cbaf 100644
--- a/models/tool_definitions.py
+++ b/models/tool_definitions.py
@@ -1,5 +1,16 @@
 from dataclasses import dataclass
-from typing import List
+from typing import List, Optional, Dict
+
+
+@dataclass
+class MCPServerDefinition:
+    """Definition for an MCP (Model Context Protocol) server connection"""
+    name: str
+    command: str
+    args: List[str]
+    env: Optional[Dict[str, str]] = None
+    connection_type: str = "stdio"
+    included_tools: Optional[List[str]] = None
 
 
 @dataclass
@@ -26,3 +37,4 @@ class AgentGoal:
     description: str = "Description of the tools purpose and overall goal"
     starter_prompt: str = "Initial prompt to start the conversation"
     example_conversation_history: str = "Example conversation history to help the AI agent understand the context of the conversation"
+    mcp_server_definition: Optional[MCPServerDefinition] = None
diff --git a/poetry.lock b/poetry.lock
index 1c7a851..fe618a1 100644
--- a/poetry.lock
+++ b/poetry.lock
@@ -191,6 +191,20 @@ docs = ["cogapp", "furo", "myst-parser", "sphinx", "sphinx-notfound-page", "sphi
 tests = ["cloudpickle", "hypothesis", "mypy (>=1.11.1)", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins", "pytest-xdist[psutil]"]
 tests-mypy = ["mypy (>=1.11.1)", "pytest-mypy-plugins"]
 
+[[package]]
+name = "authlib"
+version = "1.6.0"
+description = "The ultimate Python library in building OAuth and OpenID Connect servers and clients."
+optional = false
+python-versions = ">=3.9"
+files = [
+    {file = "authlib-1.6.0-py2.py3-none-any.whl", hash = "sha256:91685589498f79e8655e8a8947431ad6288831d643f11c55c2143ffcc738048d"},
+    {file = "authlib-1.6.0.tar.gz", hash = "sha256:4367d32031b7af175ad3a323d571dc7257b7099d55978087ceae4a0d88cd3210"},
+]
+
+[package.dependencies]
+cryptography = "*"
+
 [[package]]
 name = "black"
 version = "23.12.1"
@@ -262,6 +276,85 @@ files = [
     {file = "certifi-2024.12.14.tar.gz", hash = "sha256:b650d30f370c2b724812bee08008be0c4163b163ddaec3f2546c1caf65f191db"},
 ]
 
+[[package]]
+name = "cffi"
+version = "1.17.1"
+description = "Foreign Function Interface for Python calling C code."
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "cffi-1.17.1-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:df8b1c11f177bc2313ec4b2d46baec87a5f3e71fc8b45dab2ee7cae86d9aba14"},
+    {file = "cffi-1.17.1-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:8f2cdc858323644ab277e9bb925ad72ae0e67f69e804f4898c070998d50b1a67"},
+    {file = "cffi-1.17.1-cp310-cp310-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:edae79245293e15384b51f88b00613ba9f7198016a5948b5dddf4917d4d26382"},
+    {file = "cffi-1.17.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:45398b671ac6d70e67da8e4224a065cec6a93541bb7aebe1b198a61b58c7b702"},
+    {file = "cffi-1.17.1-cp310-cp310-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:ad9413ccdeda48c5afdae7e4fa2192157e991ff761e7ab8fdd8926f40b160cc3"},
+    {file = "cffi-1.17.1-cp310-cp310-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:5da5719280082ac6bd9aa7becb3938dc9f9cbd57fac7d2871717b1feb0902ab6"},
+    {file = "cffi-1.17.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:2bb1a08b8008b281856e5971307cc386a8e9c5b625ac297e853d36da6efe9c17"},
+    {file = "cffi-1.17.1-cp310-cp310-musllinux_1_1_aarch64.whl", hash = "sha256:045d61c734659cc045141be4bae381a41d89b741f795af1dd018bfb532fd0df8"},
+    {file = "cffi-1.17.1-cp310-cp310-musllinux_1_1_i686.whl", hash = "sha256:6883e737d7d9e4899a8a695e00ec36bd4e5e4f18fabe0aca0efe0a4b44cdb13e"},
+    {file = "cffi-1.17.1-cp310-cp310-musllinux_1_1_x86_64.whl", hash = "sha256:6b8b4a92e1c65048ff98cfe1f735ef8f1ceb72e3d5f0c25fdb12087a23da22be"},
+    {file = "cffi-1.17.1-cp310-cp310-win32.whl", hash = "sha256:c9c3d058ebabb74db66e431095118094d06abf53284d9c81f27300d0e0d8bc7c"},
+    {file = "cffi-1.17.1-cp310-cp310-win_amd64.whl", hash = "sha256:0f048dcf80db46f0098ccac01132761580d28e28bc0f78ae0d58048063317e15"},
+    {file = "cffi-1.17.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:a45e3c6913c5b87b3ff120dcdc03f6131fa0065027d0ed7ee6190736a74cd401"},
+    {file = "cffi-1.17.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:30c5e0cb5ae493c04c8b42916e52ca38079f1b235c2f8ae5f4527b963c401caf"},
+    {file = "cffi-1.17.1-cp311-cp311-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:f75c7ab1f9e4aca5414ed4d8e5c0e303a34f4421f8a0d47a4d019ceff0ab6af4"},
+    {file = "cffi-1.17.1-cp311-cp311-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a1ed2dd2972641495a3ec98445e09766f077aee98a1c896dcb4ad0d303628e41"},
+    {file = "cffi-1.17.1-cp311-cp311-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:46bf43160c1a35f7ec506d254e5c890f3c03648a4dbac12d624e4490a7046cd1"},
+    {file = "cffi-1.17.1-cp311-cp311-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:a24ed04c8ffd54b0729c07cee15a81d964e6fee0e3d4d342a27b020d22959dc6"},
+    {file = "cffi-1.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:610faea79c43e44c71e1ec53a554553fa22321b65fae24889706c0a84d4ad86d"},
+    {file = "cffi-1.17.1-cp311-cp311-musllinux_1_1_aarch64.whl", hash = "sha256:a9b15d491f3ad5d692e11f6b71f7857e7835eb677955c00cc0aefcd0669adaf6"},
+    {file = "cffi-1.17.1-cp311-cp311-musllinux_1_1_i686.whl", hash = "sha256:de2ea4b5833625383e464549fec1bc395c1bdeeb5f25c4a3a82b5a8c756ec22f"},
+    {file = "cffi-1.17.1-cp311-cp311-musllinux_1_1_x86_64.whl", hash = "sha256:fc48c783f9c87e60831201f2cce7f3b2e4846bf4d8728eabe54d60700b318a0b"},
+    {file = "cffi-1.17.1-cp311-cp311-win32.whl", hash = "sha256:85a950a4ac9c359340d5963966e3e0a94a676bd6245a4b55bc43949eee26a655"},
+    {file = "cffi-1.17.1-cp311-cp311-win_amd64.whl", hash = "sha256:caaf0640ef5f5517f49bc275eca1406b0ffa6aa184892812030f04c2abf589a0"},
+    {file = "cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl", hash = "sha256:805b4371bf7197c329fcb3ead37e710d1bca9da5d583f5073b799d5c5bd1eee4"},
+    {file = "cffi-1.17.1-cp312-cp312-macosx_11_0_arm64.whl", hash = "sha256:733e99bc2df47476e3848417c5a4540522f234dfd4ef3ab7fafdf555b082ec0c"},
+    {file = "cffi-1.17.1-cp312-cp312-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1257bdabf294dceb59f5e70c64a3e2f462c30c7ad68092d01bbbfb1c16b1ba36"},
+    {file = "cffi-1.17.1-cp312-cp312-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:da95af8214998d77a98cc14e3a3bd00aa191526343078b530ceb0bd710fb48a5"},
+    {file = "cffi-1.17.1-cp312-cp312-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:d63afe322132c194cf832bfec0dc69a99fb9bb6bbd550f161a49e9e855cc78ff"},
+    {file = "cffi-1.17.1-cp312-cp312-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:f79fc4fc25f1c8698ff97788206bb3c2598949bfe0fef03d299eb1b5356ada99"},
+    {file = "cffi-1.17.1-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:b62ce867176a75d03a665bad002af8e6d54644fad99a3c70905c543130e39d93"},
+    {file = "cffi-1.17.1-cp312-cp312-musllinux_1_1_aarch64.whl", hash = "sha256:386c8bf53c502fff58903061338ce4f4950cbdcb23e2902d86c0f722b786bbe3"},
+    {file = "cffi-1.17.1-cp312-cp312-musllinux_1_1_x86_64.whl", hash = "sha256:4ceb10419a9adf4460ea14cfd6bc43d08701f0835e979bf821052f1805850fe8"},
+    {file = "cffi-1.17.1-cp312-cp312-win32.whl", hash = "sha256:a08d7e755f8ed21095a310a693525137cfe756ce62d066e53f502a83dc550f65"},
+    {file = "cffi-1.17.1-cp312-cp312-win_amd64.whl", hash = "sha256:51392eae71afec0d0c8fb1a53b204dbb3bcabcb3c9b807eedf3e1e6ccf2de903"},
+    {file = "cffi-1.17.1-cp313-cp313-macosx_10_13_x86_64.whl", hash = "sha256:f3a2b4222ce6b60e2e8b337bb9596923045681d71e5a082783484d845390938e"},
+    {file = "cffi-1.17.1-cp313-cp313-macosx_11_0_arm64.whl", hash = "sha256:0984a4925a435b1da406122d4d7968dd861c1385afe3b45ba82b750f229811e2"},
+    {file = "cffi-1.17.1-cp313-cp313-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:d01b12eeeb4427d3110de311e1774046ad344f5b1a7403101878976ecd7a10f3"},
+    {file = "cffi-1.17.1-cp313-cp313-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:706510fe141c86a69c8ddc029c7910003a17353970cff3b904ff0686a5927683"},
+    {file = "cffi-1.17.1-cp313-cp313-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:de55b766c7aa2e2a3092c51e0483d700341182f08e67c63630d5b6f200bb28e5"},
+    {file = "cffi-1.17.1-cp313-cp313-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:c59d6e989d07460165cc5ad3c61f9fd8f1b4796eacbd81cee78957842b834af4"},
+    {file = "cffi-1.17.1-cp313-cp313-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:dd398dbc6773384a17fe0d3e7eeb8d1a21c2200473ee6806bb5e6a8e62bb73dd"},
+    {file = "cffi-1.17.1-cp313-cp313-musllinux_1_1_aarch64.whl", hash = "sha256:3edc8d958eb099c634dace3c7e16560ae474aa3803a5df240542b305d14e14ed"},
+    {file = "cffi-1.17.1-cp313-cp313-musllinux_1_1_x86_64.whl", hash = "sha256:72e72408cad3d5419375fc87d289076ee319835bdfa2caad331e377589aebba9"},
+    {file = "cffi-1.17.1-cp313-cp313-win32.whl", hash = "sha256:e03eab0a8677fa80d646b5ddece1cbeaf556c313dcfac435ba11f107ba117b5d"},
+    {file = "cffi-1.17.1-cp313-cp313-win_amd64.whl", hash = "sha256:f6a16c31041f09ead72d69f583767292f750d24913dadacf5756b966aacb3f1a"},
+    {file = "cffi-1.17.1-cp38-cp38-macosx_10_9_x86_64.whl", hash = "sha256:636062ea65bd0195bc012fea9321aca499c0504409f413dc88af450b57ffd03b"},
+    {file = "cffi-1.17.1-cp38-cp38-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:c7eac2ef9b63c79431bc4b25f1cd649d7f061a28808cbc6c47b534bd789ef964"},
+    {file = "cffi-1.17.1-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:e221cf152cff04059d011ee126477f0d9588303eb57e88923578ace7baad17f9"},
+    {file = "cffi-1.17.1-cp38-cp38-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:31000ec67d4221a71bd3f67df918b1f88f676f1c3b535a7eb473255fdc0b83fc"},
+    {file = "cffi-1.17.1-cp38-cp38-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:6f17be4345073b0a7b8ea599688f692ac3ef23ce28e5df79c04de519dbc4912c"},
+    {file = "cffi-1.17.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:0e2b1fac190ae3ebfe37b979cc1ce69c81f4e4fe5746bb401dca63a9062cdaf1"},
+    {file = "cffi-1.17.1-cp38-cp38-win32.whl", hash = "sha256:7596d6620d3fa590f677e9ee430df2958d2d6d6de2feeae5b20e82c00b76fbf8"},
+    {file = "cffi-1.17.1-cp38-cp38-win_amd64.whl", hash = "sha256:78122be759c3f8a014ce010908ae03364d00a1f81ab5c7f4a7a5120607ea56e1"},
+    {file = "cffi-1.17.1-cp39-cp39-macosx_10_9_x86_64.whl", hash = "sha256:b2ab587605f4ba0bf81dc0cb08a41bd1c0a5906bd59243d56bad7668a6fc6c16"},
+    {file = "cffi-1.17.1-cp39-cp39-macosx_11_0_arm64.whl", hash = "sha256:28b16024becceed8c6dfbc75629e27788d8a3f9030691a1dbf9821a128b22c36"},
+    {file = "cffi-1.17.1-cp39-cp39-manylinux_2_12_i686.manylinux2010_i686.manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:1d599671f396c4723d016dbddb72fe8e0397082b0a77a4fab8028923bec050e8"},
+    {file = "cffi-1.17.1-cp39-cp39-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:ca74b8dbe6e8e8263c0ffd60277de77dcee6c837a3d0881d8c1ead7268c9e576"},
+    {file = "cffi-1.17.1-cp39-cp39-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:f7f5baafcc48261359e14bcd6d9bff6d4b28d9103847c9e136694cb0501aef87"},
+    {file = "cffi-1.17.1-cp39-cp39-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:98e3969bcff97cae1b2def8ba499ea3d6f31ddfdb7635374834cf89a1a08ecf0"},
+    {file = "cffi-1.17.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:cdf5ce3acdfd1661132f2a9c19cac174758dc2352bfe37d98aa7512c6b7178b3"},
+    {file = "cffi-1.17.1-cp39-cp39-musllinux_1_1_aarch64.whl", hash = "sha256:9755e4345d1ec879e3849e62222a18c7174d65a6a92d5b346b1863912168b595"},
+    {file = "cffi-1.17.1-cp39-cp39-musllinux_1_1_i686.whl", hash = "sha256:f1e22e8c4419538cb197e4dd60acc919d7696e5ef98ee4da4e01d3f8cfa4cc5a"},
+    {file = "cffi-1.17.1-cp39-cp39-musllinux_1_1_x86_64.whl", hash = "sha256:c03e868a0b3bc35839ba98e74211ed2b05d2119be4e8a0f224fba9384f1fe02e"},
+    {file = "cffi-1.17.1-cp39-cp39-win32.whl", hash = "sha256:e31ae45bc2e29f6b2abd0de1cc3b9d5205aa847cafaecb8af1476a609a2f6eb7"},
+    {file = "cffi-1.17.1-cp39-cp39-win_amd64.whl", hash = "sha256:d016c76bdd850f3c626af19b0542c9677ba156e4ee4fccfdd7848803533ef662"},
+    {file = "cffi-1.17.1.tar.gz", hash = "sha256:1c39c6016c32bc48dd54561950ebd6836e1670f2ae46128f67cf49e789c52824"},
+]
+
+[package.dependencies]
+pycparser = "*"
+
 [[package]]
 name = "charset-normalizer"
 version = "3.4.1"
@@ -388,6 +481,65 @@ files = [
     {file = "colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44"},
 ]
 
+[[package]]
+name = "cryptography"
+version = "45.0.3"
+description = "cryptography is a package which provides cryptographic recipes and primitives to Python developers."
+optional = false
+python-versions = "!=3.9.0,!=3.9.1,>=3.7"
+files = [
+    {file = "cryptography-45.0.3-cp311-abi3-macosx_10_9_universal2.whl", hash = "sha256:7573d9eebaeceeb55285205dbbb8753ac1e962af3d9640791d12b36864065e71"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:d377dde61c5d67eb4311eace661c3efda46c62113ff56bf05e2d679e02aebb5b"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:fae1e637f527750811588e4582988932c222f8251f7b7ea93739acb624e1487f"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_28_aarch64.whl", hash = "sha256:ca932e11218bcc9ef812aa497cdf669484870ecbcf2d99b765d6c27a86000942"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_28_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:af3f92b1dc25621f5fad065288a44ac790c5798e986a34d393ab27d2b27fcff9"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_28_x86_64.whl", hash = "sha256:2f8f8f0b73b885ddd7f3d8c2b2234a7d3ba49002b0223f58cfde1bedd9563c56"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_34_aarch64.whl", hash = "sha256:9cc80ce69032ffa528b5e16d217fa4d8d4bb7d6ba8659c1b4d74a1b0f4235fca"},
+    {file = "cryptography-45.0.3-cp311-abi3-manylinux_2_34_x86_64.whl", hash = "sha256:c824c9281cb628015bfc3c59335163d4ca0540d49de4582d6c2637312907e4b1"},
+    {file = "cryptography-45.0.3-cp311-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:5833bb4355cb377ebd880457663a972cd044e7f49585aee39245c0d592904578"},
+    {file = "cryptography-45.0.3-cp311-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:9bb5bf55dcb69f7067d80354d0a348368da907345a2c448b0babc4215ccd3497"},
+    {file = "cryptography-45.0.3-cp311-abi3-win32.whl", hash = "sha256:3ad69eeb92a9de9421e1f6685e85a10fbcfb75c833b42cc9bc2ba9fb00da4710"},
+    {file = "cryptography-45.0.3-cp311-abi3-win_amd64.whl", hash = "sha256:97787952246a77d77934d41b62fb1b6f3581d83f71b44796a4158d93b8f5c490"},
+    {file = "cryptography-45.0.3-cp37-abi3-macosx_10_9_universal2.whl", hash = "sha256:c92519d242703b675ccefd0f0562eb45e74d438e001f8ab52d628e885751fb06"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:c5edcb90da1843df85292ef3a313513766a78fbbb83f584a5a58fb001a5a9d57"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:38deed72285c7ed699864f964a3f4cf11ab3fb38e8d39cfcd96710cd2b5bb716"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_28_aarch64.whl", hash = "sha256:5555365a50efe1f486eed6ac7062c33b97ccef409f5970a0b6f205a7cfab59c8"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_28_armv7l.manylinux_2_31_armv7l.whl", hash = "sha256:9e4253ed8f5948a3589b3caee7ad9a5bf218ffd16869c516535325fece163dcc"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_28_x86_64.whl", hash = "sha256:cfd84777b4b6684955ce86156cfb5e08d75e80dc2585e10d69e47f014f0a5342"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_34_aarch64.whl", hash = "sha256:a2b56de3417fd5f48773ad8e91abaa700b678dc7fe1e0c757e1ae340779acf7b"},
+    {file = "cryptography-45.0.3-cp37-abi3-manylinux_2_34_x86_64.whl", hash = "sha256:57a6500d459e8035e813bd8b51b671977fb149a8c95ed814989da682314d0782"},
+    {file = "cryptography-45.0.3-cp37-abi3-musllinux_1_2_aarch64.whl", hash = "sha256:f22af3c78abfbc7cbcdf2c55d23c3e022e1a462ee2481011d518c7fb9c9f3d65"},
+    {file = "cryptography-45.0.3-cp37-abi3-musllinux_1_2_x86_64.whl", hash = "sha256:232954730c362638544758a8160c4ee1b832dc011d2c41a306ad8f7cccc5bb0b"},
+    {file = "cryptography-45.0.3-cp37-abi3-win32.whl", hash = "sha256:cb6ab89421bc90e0422aca911c69044c2912fc3debb19bb3c1bfe28ee3dff6ab"},
+    {file = "cryptography-45.0.3-cp37-abi3-win_amd64.whl", hash = "sha256:d54ae41e6bd70ea23707843021c778f151ca258081586f0cfa31d936ae43d1b2"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-macosx_10_9_x86_64.whl", hash = "sha256:ed43d396f42028c1f47b5fec012e9e12631266e3825e95c00e3cf94d472dac49"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-manylinux_2_28_aarch64.whl", hash = "sha256:fed5aaca1750e46db870874c9c273cd5182a9e9deb16f06f7bdffdb5c2bde4b9"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-manylinux_2_28_x86_64.whl", hash = "sha256:00094838ecc7c6594171e8c8a9166124c1197b074cfca23645cee573910d76bc"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-manylinux_2_34_aarch64.whl", hash = "sha256:92d5f428c1a0439b2040435a1d6bc1b26ebf0af88b093c3628913dd464d13fa1"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-manylinux_2_34_x86_64.whl", hash = "sha256:ec64ee375b5aaa354b2b273c921144a660a511f9df8785e6d1c942967106438e"},
+    {file = "cryptography-45.0.3-pp310-pypy310_pp73-win_amd64.whl", hash = "sha256:71320fbefd05454ef2d457c481ba9a5b0e540f3753354fff6f780927c25d19b0"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-macosx_10_9_x86_64.whl", hash = "sha256:edd6d51869beb7f0d472e902ef231a9b7689508e83880ea16ca3311a00bf5ce7"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-manylinux_2_28_aarch64.whl", hash = "sha256:555e5e2d3a53b4fabeca32835878b2818b3f23966a4efb0d566689777c5a12c8"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-manylinux_2_28_x86_64.whl", hash = "sha256:25286aacb947286620a31f78f2ed1a32cded7be5d8b729ba3fb2c988457639e4"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-manylinux_2_34_aarch64.whl", hash = "sha256:050ce5209d5072472971e6efbfc8ec5a8f9a841de5a4db0ebd9c2e392cb81972"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-manylinux_2_34_x86_64.whl", hash = "sha256:dc10ec1e9f21f33420cc05214989544727e776286c1c16697178978327b95c9c"},
+    {file = "cryptography-45.0.3-pp311-pypy311_pp73-win_amd64.whl", hash = "sha256:9eda14f049d7f09c2e8fb411dda17dd6b16a3c76a1de5e249188a32aeb92de19"},
+    {file = "cryptography-45.0.3.tar.gz", hash = "sha256:ec21313dd335c51d7877baf2972569f40a4291b76a0ce51391523ae358d05899"},
+]
+
+[package.dependencies]
+cffi = {version = ">=1.14", markers = "platform_python_implementation != \"PyPy\""}
+
+[package.extras]
+docs = ["sphinx (>=5.3.0)", "sphinx-inline-tabs", "sphinx-rtd-theme (>=3.0.0)"]
+docstest = ["pyenchant (>=3)", "readme-renderer (>=30.0)", "sphinxcontrib-spelling (>=7.3.1)"]
+nox = ["nox (>=2024.4.15)", "nox[uv] (>=2024.3.2)"]
+pep8test = ["check-sdist", "click (>=8.0.1)", "mypy (>=1.4)", "ruff (>=0.3.6)"]
+sdist = ["build (>=1.0.0)"]
+ssh = ["bcrypt (>=3.1.5)"]
+test = ["certifi (>=2024)", "cryptography-vectors (==45.0.3)", "pretend (>=0.7)", "pytest (>=7.4.0)", "pytest-benchmark (>=4.0)", "pytest-cov (>=2.10.1)", "pytest-xdist (>=3.5.0)"]
+test-randomorder = ["pytest-randomly"]
+
 [[package]]
 name = "distro"
 version = "1.9.0"
@@ -433,6 +585,30 @@ typing-extensions = ">=4.8.0"
 all = ["email-validator (>=2.0.0)", "fastapi-cli[standard] (>=0.0.5)", "httpx (>=0.23.0)", "itsdangerous (>=1.1.0)", "jinja2 (>=2.11.2)", "orjson (>=3.2.1)", "pydantic-extra-types (>=2.0.0)", "pydantic-settings (>=2.0.0)", "python-multipart (>=0.0.7)", "pyyaml (>=5.3.1)", "ujson (>=4.0.1,!=4.0.2,!=4.1.0,!=4.2.0,!=4.3.0,!=5.0.0,!=5.1.0)", "uvicorn[standard] (>=0.12.0)"]
 standard = ["email-validator (>=2.0.0)", "fastapi-cli[standard] (>=0.0.5)", "httpx (>=0.23.0)", "jinja2 (>=2.11.2)", "python-multipart (>=0.0.7)", "uvicorn[standard] (>=0.12.0)"]
 
+[[package]]
+name = "fastmcp"
+version = "2.7.0"
+description = "The fast, Pythonic way to build MCP servers."
+optional = false
+python-versions = ">=3.10"
+files = [
+    {file = "fastmcp-2.7.0-py3-none-any.whl", hash = "sha256:5e0827a37bc71656edebb5f217423ce6f838d8f0e42f79c9f803349c0366fc80"},
+    {file = "fastmcp-2.7.0.tar.gz", hash = "sha256:6a081400ed46e1b74fbda3f5b7f806180f4091b7bf36bd4c52d7074934767004"},
+]
+
+[package.dependencies]
+authlib = ">=1.5.2"
+exceptiongroup = ">=1.2.2"
+httpx = ">=0.28.1"
+mcp = ">=1.9.2,<2.0.0"
+openapi-pydantic = ">=0.5.1"
+python-dotenv = ">=1.1.0"
+rich = ">=13.9.4"
+typer = ">=0.15.2"
+
+[package.extras]
+websockets = ["websockets (>=15.0.1)"]
+
 [[package]]
 name = "filelock"
 version = "3.18.0"
@@ -699,13 +875,13 @@ trio = ["trio (>=0.22.0,<1.0)"]
 
 [[package]]
 name = "httpx"
-version = "0.27.2"
+version = "0.28.1"
 description = "The next generation HTTP client."
 optional = false
 python-versions = ">=3.8"
 files = [
-    {file = "httpx-0.27.2-py3-none-any.whl", hash = "sha256:7bb2708e112d8fdd7829cd4243970f0c223274051cb35ee80c03301ee29a3df0"},
-    {file = "httpx-0.27.2.tar.gz", hash = "sha256:f7c2be1d2f3c3c3160d441802406b206c2b76f5947b11115e6df10c6c65e66c2"},
+    {file = "httpx-0.28.1-py3-none-any.whl", hash = "sha256:d909fcccc110f8c7faf814ca82a9a4d816bc5a6dbfea25d6591d6985b8ba59ad"},
+    {file = "httpx-0.28.1.tar.gz", hash = "sha256:75e98c5f16b0f35b567856f597f06ff2270a374470a5c2392242528e3e3e42fc"},
 ]
 
 [package.dependencies]
@@ -713,7 +889,6 @@ anyio = "*"
 certifi = "*"
 httpcore = "==1.*"
 idna = "*"
-sniffio = "*"
 
 [package.extras]
 brotli = ["brotli", "brotlicffi"]
@@ -722,6 +897,17 @@ http2 = ["h2 (>=3,<5)"]
 socks = ["socksio (==1.*)"]
 zstd = ["zstandard (>=0.18.0)"]
 
+[[package]]
+name = "httpx-sse"
+version = "0.4.0"
+description = "Consume Server-Sent Event (SSE) messages with HTTPX."
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721"},
+    {file = "httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f"},
+]
+
 [[package]]
 name = "huggingface-hub"
 version = "0.31.4"
@@ -995,6 +1181,30 @@ extra-proxy = ["azure-identity (>=1.15.0,<2.0.0)", "azure-keyvault-secrets (>=4.
 proxy = ["PyJWT (>=2.8.0,<3.0.0)", "apscheduler (>=3.10.4,<4.0.0)", "backoff", "boto3 (==1.34.34)", "cryptography (>=43.0.1,<44.0.0)", "fastapi (>=0.115.5,<0.116.0)", "fastapi-sso (>=0.16.0,<0.17.0)", "gunicorn (>=23.0.0,<24.0.0)", "litellm-enterprise (==0.1.3)", "litellm-proxy-extras (==0.1.21)", "mcp (==1.5.0)", "orjson (>=3.9.7,<4.0.0)", "pynacl (>=1.5.0,<2.0.0)", "python-multipart (>=0.0.18,<0.0.19)", "pyyaml (>=6.0.1,<7.0.0)", "rich (==13.7.1)", "rq", "uvicorn (>=0.29.0,<0.30.0)", "uvloop (>=0.21.0,<0.22.0)", "websockets (>=13.1.0,<14.0.0)"]
 utils = ["numpydoc"]
 
+[[package]]
+name = "markdown-it-py"
+version = "3.0.0"
+description = "Python port of markdown-it. Markdown parsing, done right!"
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "markdown-it-py-3.0.0.tar.gz", hash = "sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb"},
+    {file = "markdown_it_py-3.0.0-py3-none-any.whl", hash = "sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1"},
+]
+
+[package.dependencies]
+mdurl = ">=0.1,<1.0"
+
+[package.extras]
+benchmarking = ["psutil", "pytest", "pytest-benchmark"]
+code-style = ["pre-commit (>=3.0,<4.0)"]
+compare = ["commonmark (>=0.9,<1.0)", "markdown (>=3.4,<4.0)", "mistletoe (>=1.0,<2.0)", "mistune (>=2.0,<3.0)", "panflute (>=2.3,<3.0)"]
+linkify = ["linkify-it-py (>=1,<3)"]
+plugins = ["mdit-py-plugins"]
+profiling = ["gprof2dot"]
+rtd = ["jupyter_sphinx", "mdit-py-plugins", "myst-parser", "pyyaml", "sphinx", "sphinx-copybutton", "sphinx-design", "sphinx_book_theme"]
+testing = ["coverage", "pytest", "pytest-cov", "pytest-regressions"]
+
 [[package]]
 name = "markupsafe"
 version = "3.0.2"
@@ -1065,6 +1275,44 @@ files = [
     {file = "markupsafe-3.0.2.tar.gz", hash = "sha256:ee55d3edf80167e48ea11a923c7386f4669df67d7994554387f84e7d8b0a2bf0"},
 ]
 
+[[package]]
+name = "mcp"
+version = "1.9.3"
+description = "Model Context Protocol SDK"
+optional = false
+python-versions = ">=3.10"
+files = [
+    {file = "mcp-1.9.3-py3-none-any.whl", hash = "sha256:69b0136d1ac9927402ed4cf221d4b8ff875e7132b0b06edd446448766f34f9b9"},
+    {file = "mcp-1.9.3.tar.gz", hash = "sha256:587ba38448e81885e5d1b84055cfcc0ca56d35cd0c58f50941cab01109405388"},
+]
+
+[package.dependencies]
+anyio = ">=4.5"
+httpx = ">=0.27"
+httpx-sse = ">=0.4"
+pydantic = ">=2.7.2,<3.0.0"
+pydantic-settings = ">=2.5.2"
+python-multipart = ">=0.0.9"
+sse-starlette = ">=1.6.1"
+starlette = ">=0.27"
+uvicorn = {version = ">=0.23.1", markers = "sys_platform != \"emscripten\""}
+
+[package.extras]
+cli = ["python-dotenv (>=1.0.0)", "typer (>=0.12.4)"]
+rich = ["rich (>=13.9.4)"]
+ws = ["websockets (>=15.0.1)"]
+
+[[package]]
+name = "mdurl"
+version = "0.1.2"
+description = "Markdown URL utilities"
+optional = false
+python-versions = ">=3.7"
+files = [
+    {file = "mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8"},
+    {file = "mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba"},
+]
+
 [[package]]
 name = "multidict"
 version = "6.4.4"
@@ -1336,6 +1584,20 @@ datalib = ["numpy (>=1)", "pandas (>=1.2.3)", "pandas-stubs (>=1.1.0.11)"]
 realtime = ["websockets (>=13,<16)"]
 voice-helpers = ["numpy (>=2.0.2)", "sounddevice (>=0.5.1)"]
 
+[[package]]
+name = "openapi-pydantic"
+version = "0.5.1"
+description = "Pydantic OpenAPI schema implementation"
+optional = false
+python-versions = "<4.0,>=3.8"
+files = [
+    {file = "openapi_pydantic-0.5.1-py3-none-any.whl", hash = "sha256:a3a09ef4586f5bd760a8df7f43028b60cafb6d9f61de2acba9574766255ab146"},
+    {file = "openapi_pydantic-0.5.1.tar.gz", hash = "sha256:ff6835af6bde7a459fb93eb93bb92b8749b754fc6e51b2f1590a19dc3005ee0d"},
+]
+
+[package.dependencies]
+pydantic = ">=1.8"
+
 [[package]]
 name = "packaging"
 version = "24.2"
@@ -1602,6 +1864,17 @@ files = [
     {file = "protobuf-5.29.2.tar.gz", hash = "sha256:b2cc8e8bb7c9326996f0e160137b0861f1a82162502658df2951209d0cb0309e"},
 ]
 
+[[package]]
+name = "pycparser"
+version = "2.22"
+description = "C parser in Python"
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "pycparser-2.22-py3-none-any.whl", hash = "sha256:c3702b6d3dd8c7abc1afa565d7e63d53a1d0bd86cdc24edd75470f4de499cfcc"},
+    {file = "pycparser-2.22.tar.gz", hash = "sha256:491c8be9c040f5390f5bf44a5b07752bd07f56edf992381b05c701439eec10f6"},
+]
+
 [[package]]
 name = "pydantic"
 version = "2.10.4"
@@ -1734,6 +2007,43 @@ files = [
 [package.dependencies]
 typing-extensions = ">=4.6.0,<4.7.0 || >4.7.0"
 
+[[package]]
+name = "pydantic-settings"
+version = "2.9.1"
+description = "Settings management using Pydantic"
+optional = false
+python-versions = ">=3.9"
+files = [
+    {file = "pydantic_settings-2.9.1-py3-none-any.whl", hash = "sha256:59b4f431b1defb26fe620c71a7d3968a710d719f5f4cdbbdb7926edeb770f6ef"},
+    {file = "pydantic_settings-2.9.1.tar.gz", hash = "sha256:c509bf79d27563add44e8446233359004ed85066cd096d8b510f715e6ef5d268"},
+]
+
+[package.dependencies]
+pydantic = ">=2.7.0"
+python-dotenv = ">=0.21.0"
+typing-inspection = ">=0.4.0"
+
+[package.extras]
+aws-secrets-manager = ["boto3 (>=1.35.0)", "boto3-stubs[secretsmanager]"]
+azure-key-vault = ["azure-identity (>=1.16.0)", "azure-keyvault-secrets (>=4.8.0)"]
+gcp-secret-manager = ["google-cloud-secret-manager (>=2.23.1)"]
+toml = ["tomli (>=2.0.1)"]
+yaml = ["pyyaml (>=6.0.1)"]
+
+[[package]]
+name = "pygments"
+version = "2.19.1"
+description = "Pygments is a syntax highlighting package written in Python."
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "pygments-2.19.1-py3-none-any.whl", hash = "sha256:9ea1544ad55cecf4b8242fab6dd35a93bbce657034b0611ee383099054ab6d8c"},
+    {file = "pygments-2.19.1.tar.gz", hash = "sha256:61c16d2a8576dc0649d9f39e089b5f02bcd27fba10d8fb4dcc28173f7a45151f"},
+]
+
+[package.extras]
+windows-terminal = ["colorama (>=0.4.6)"]
+
 [[package]]
 name = "pyogrio"
 version = "0.10.0"
@@ -1878,18 +2188,29 @@ six = ">=1.5"
 
 [[package]]
 name = "python-dotenv"
-version = "1.0.1"
+version = "1.1.0"
 description = "Read key-value pairs from a .env file and set them as environment variables"
 optional = false
-python-versions = ">=3.8"
+python-versions = ">=3.9"
 files = [
-    {file = "python-dotenv-1.0.1.tar.gz", hash = "sha256:e324ee90a023d808f1959c46bcbc04446a10ced277783dc6ee09987c37ec10ca"},
-    {file = "python_dotenv-1.0.1-py3-none-any.whl", hash = "sha256:f7b63ef50f1b690dddf550d03497b66d609393b40b564ed0d674909a68ebf16a"},
+    {file = "python_dotenv-1.1.0-py3-none-any.whl", hash = "sha256:d7c01d9e2293916c18baf562d95698754b0dbbb5e74d457c45d4f6561fb9d55d"},
+    {file = "python_dotenv-1.1.0.tar.gz", hash = "sha256:41f90bc6f5f177fb41f53e87666db362025010eb28f60a01c9143bfa33a2b2d5"},
 ]
 
 [package.extras]
 cli = ["click (>=5.0)"]
 
+[[package]]
+name = "python-multipart"
+version = "0.0.20"
+description = "A streaming multipart parser for Python"
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "python_multipart-0.0.20-py3-none-any.whl", hash = "sha256:8a62d3a8335e06589fe01f2a3e178cdcc632f3fbe0d492ad9ee0ec35aab1f104"},
+    {file = "python_multipart-0.0.20.tar.gz", hash = "sha256:8dd0cab45b8e23064ae09147625994d090fa46f5b0d1e13af944c331a7fa9d13"},
+]
+
 [[package]]
 name = "pytz"
 version = "2025.1"
@@ -2103,6 +2424,25 @@ urllib3 = ">=1.21.1,<3"
 socks = ["PySocks (>=1.5.6,!=1.5.7)"]
 use-chardet-on-py3 = ["chardet (>=3.0.2,<6)"]
 
+[[package]]
+name = "rich"
+version = "14.0.0"
+description = "Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal"
+optional = false
+python-versions = ">=3.8.0"
+files = [
+    {file = "rich-14.0.0-py3-none-any.whl", hash = "sha256:1c9491e1951aac09caffd42f448ee3d04e58923ffe14993f6e83068dc395d7e0"},
+    {file = "rich-14.0.0.tar.gz", hash = "sha256:82f1bc23a6a21ebca4ae0c45af9bdbc492ed20231dcb63f297d6d1021a9d5725"},
+]
+
+[package.dependencies]
+markdown-it-py = ">=2.2.0"
+pygments = ">=2.13.0,<3.0.0"
+typing-extensions = {version = ">=4.0.0,<5.0", markers = "python_version < \"3.11\""}
+
+[package.extras]
+jupyter = ["ipywidgets (>=7.5.1,<9)"]
+
 [[package]]
 name = "rpds-py"
 version = "0.25.0"
@@ -2303,6 +2643,17 @@ numpy = ">=1.14,<3"
 docs = ["matplotlib", "numpydoc (==1.1.*)", "sphinx", "sphinx-book-theme", "sphinx-remove-toctrees"]
 test = ["pytest", "pytest-cov"]
 
+[[package]]
+name = "shellingham"
+version = "1.5.4"
+description = "Tool to Detect Surrounding Shell"
+optional = false
+python-versions = ">=3.7"
+files = [
+    {file = "shellingham-1.5.4-py2.py3-none-any.whl", hash = "sha256:7ecfff8f2fd72616f7481040475a65b2bf8af90a56c89140852d1120324e8686"},
+    {file = "shellingham-1.5.4.tar.gz", hash = "sha256:8dbca0739d487e5bd35ab3ca4b36e11c4078f3a234bfce294b0a0291363404de"},
+]
+
 [[package]]
 name = "six"
 version = "1.17.0"
@@ -2325,6 +2676,25 @@ files = [
     {file = "sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc"},
 ]
 
+[[package]]
+name = "sse-starlette"
+version = "2.1.3"
+description = "SSE plugin for Starlette"
+optional = false
+python-versions = ">=3.8"
+files = [
+    {file = "sse_starlette-2.1.3-py3-none-any.whl", hash = "sha256:8ec846438b4665b9e8c560fcdea6bc8081a3abf7942faa95e5a744999d219772"},
+    {file = "sse_starlette-2.1.3.tar.gz", hash = "sha256:9cd27eb35319e1414e3d2558ee7414487f9529ce3b3cf9b21434fd110e017169"},
+]
+
+[package.dependencies]
+anyio = "*"
+starlette = "*"
+uvicorn = "*"
+
+[package.extras]
+examples = ["fastapi"]
+
 [[package]]
 name = "starlette"
 version = "0.41.3"
@@ -2523,6 +2893,23 @@ notebook = ["ipywidgets (>=6)"]
 slack = ["slack-sdk"]
 telegram = ["requests"]
 
+[[package]]
+name = "typer"
+version = "0.16.0"
+description = "Typer, build great CLIs. Easy to code. Based on Python type hints."
+optional = false
+python-versions = ">=3.7"
+files = [
+    {file = "typer-0.16.0-py3-none-any.whl", hash = "sha256:1f79bed11d4d02d4310e3c1b7ba594183bcedb0ac73b27a9e5f28f6fb5b98855"},
+    {file = "typer-0.16.0.tar.gz", hash = "sha256:af377ffaee1dbe37ae9440cb4e8f11686ea5ce4e9bae01b84ae7c63b87f1dd3b"},
+]
+
+[package.dependencies]
+click = ">=8.0.0"
+rich = ">=10.11.0"
+shellingham = ">=1.3.0"
+typing-extensions = ">=3.7.4.3"
+
 [[package]]
 name = "types-protobuf"
 version = "5.29.1.20241207"
@@ -2545,6 +2932,20 @@ files = [
     {file = "typing_extensions-4.12.2.tar.gz", hash = "sha256:1a7ead55c7e559dd4dee8856e3a88b41225abfe1ce8df57b7c13915fe121ffb8"},
 ]
 
+[[package]]
+name = "typing-inspection"
+version = "0.4.1"
+description = "Runtime typing introspection tools"
+optional = false
+python-versions = ">=3.9"
+files = [
+    {file = "typing_inspection-0.4.1-py3-none-any.whl", hash = "sha256:389055682238f53b04f7badcb49b989835495a96700ced5dab2d8feae4b26f51"},
+    {file = "typing_inspection-0.4.1.tar.gz", hash = "sha256:6ae134cc0203c33377d43188d4064e9b357dba58cff3185f22924610e70a9d28"},
+]
+
+[package.dependencies]
+typing-extensions = ">=4.12.0"
+
 [[package]]
 name = "tzdata"
 version = "2025.1"
@@ -2743,4 +3144,4 @@ type = ["pytest-mypy"]
 [metadata]
 lock-version = "2.0"
 python-versions = ">=3.10,<4.0"
-content-hash = "b391df89fabb111e4dd5d65a52a9db3a0bf9d95d5473e77cd0946beb940cf26f"
+content-hash = "41d877763533efcd55e029b5686965972f9fcfee2c5e2183db2cb1d0c5b197e2"
diff --git a/prompts/agent_prompt_generators.py b/prompts/agent_prompt_generators.py
index 4fa8220..a04f0dd 100644
--- a/prompts/agent_prompt_generators.py
+++ b/prompts/agent_prompt_generators.py
@@ -11,6 +11,7 @@ def generate_genai_prompt(
     conversation_history: str,
     multi_goal_mode: bool,
     raw_json: Optional[str] = None,
+    mcp_tools_info: Optional[dict] = None,
 ) -> str:
     """
     Generates a concise prompt for producing or validating JSON instructions
@@ -48,6 +49,20 @@ def generate_genai_prompt(
         prompt_lines.append("END EXAMPLE")
         prompt_lines.append("")
 
+    # Add MCP server context if present
+    if agent_goal.mcp_server_definition:
+        prompt_lines.append("=== MCP Server Information ===")
+        prompt_lines.append(f"Connected to MCP Server: {agent_goal.mcp_server_definition.name}")
+        if mcp_tools_info and mcp_tools_info.get("success", False):
+            tools = mcp_tools_info.get("tools", {})
+            server_name = mcp_tools_info.get("server_name", "Unknown")
+            prompt_lines.append(f"MCP Tools loaded from {server_name} ({len(tools)} tools):")
+            for tool_name, tool_info in tools.items():
+                prompt_lines.append(f"  - {tool_name}: {tool_info.get('description', 'No description')}")
+        else:
+            prompt_lines.append("Additional tools available via MCP integration:")
+        prompt_lines.append("")
+
     # Tools Definitions
     prompt_lines.append("=== Tools Definitions ===")
     prompt_lines.append(f"There are {len(agent_goal.tools)} available tools:")
@@ -102,11 +117,20 @@ def generate_genai_prompt(
         "3) You can carry over arguments from one tool to another.\n "
         "EXAMPLE: If you asked for an account ID, then use the conversation history to infer that argument "
         "going forward."
-        "4) If ListAgents in the conversation history is force_confirm='False', you MUST check "
-        + "if the current tool contains userConfirmation. If it does, please ask the user to confirm details "
-        + "with the user. userConfirmation overrides force_confirm='False'.\n"
-        + "EXAMPLE: (force_confirm='False' AND userConfirmation exists on tool) Would you like me to <run tool> "
-        + "with the following details: <details>?\n"
+        "4) CRITICAL: Use sensible defaults for technical parameters instead of asking users. "
+        "EXAMPLE: For list_products, use limit=100 instead of asking 'how many items would you like to see?'"
+        "EXAMPLE: For browsing menus, show all relevant items rather than asking for technical limits."
+        "5) CRITICAL: When users specify quantities (like '2 garlic breads'), be explicit in your response about the quantity. "
+        "EXAMPLE: User says '2 garlic breads' -> response: 'Adding 2 Garlic Breads to your cart ($7.99 each).'"
+        "EXAMPLE: Always confirm the exact quantity being added before proceeding with next='confirm'."
+        "6) CRITICAL: If ListAgents in the conversation history is force_confirm='False', you MUST NOT ask permission "
+        + "or include any questions in your response unless the current tool has userConfirmation defined. "
+        + "NEVER say 'Is that okay?', 'Would you like me to...?', 'Should I...?', or any similar questions. "
+        + "Instead, use confident declarative statements and set next='confirm' to execute immediately.\n"
+        + "EXAMPLE: (force_confirm='False' AND no userConfirmation) -> response: 'Getting our menu items now.' next='confirm'\n"
+        + "EXAMPLE: (force_confirm='False' AND no userConfirmation) -> response: 'Adding the pizza to your cart.' next='confirm'\n"
+        + "EXAMPLE: (force_confirm='False' AND userConfirmation exists on tool) -> response: 'Would you like me to <run tool> "
+        + "with the following details: <details>?' next='question'\n"
     )
 
     # Validation Task (If raw_json is provided)
@@ -232,6 +256,6 @@ def generate_toolchain_complete_guidance() -> str:
         str: A prompt string prompting the LLM to prompt for a new goal, or be done
     """
     if is_multi_goal_mode():
-        return "If no more tools are needed (user_confirmed_tool_run has been run for all), set next='confirm' and tool='ListAgents'."
+        return "If no more tools are needed for the current goal (user_confirmed_tool_run has been run for all required tools), set next='pick-new-goal' and tool=null to allow the user to choose their next action."
     else:
-        return "If no more tools are needed (user_confirmed_tool_run has been run for all), set next='done' and tool=''."
+        return "If no more tools are needed (user_confirmed_tool_run has been run for all), set next='done' and tool=null."
diff --git a/pyproject.toml b/pyproject.toml
index 9c00784..860982a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -40,6 +40,7 @@ requests = "^2.32.3"
 pandas = "^2.2.3"
 stripe = "^11.4.1"
 gtfs-kit = "^10.1.1"
+fastmcp = "^2.7.0"
 
 [tool.poetry.group.dev.dependencies]
 pytest = ">=8.2"
diff --git a/scripts/run_worker.py b/scripts/run_worker.py
index a5a4d8a..864a7b8 100644
--- a/scripts/run_worker.py
+++ b/scripts/run_worker.py
@@ -6,7 +6,11 @@ import os
 from dotenv import load_dotenv
 from temporalio.worker import Worker
 
-from activities.tool_activities import ToolActivities, dynamic_tool_activity
+from activities.tool_activities import (
+    ToolActivities,
+    dynamic_tool_activity,
+    mcp_list_tools,
+)
 from shared.config import TEMPORAL_TASK_QUEUE, get_temporal_client
 from workflows.agent_goal_workflow import AgentGoalWorkflow
 
@@ -48,7 +52,7 @@ async def main():
             print("===========================================================\n")
 
     print("Worker ready to process tasks!")
-    logging.basicConfig(level=logging.WARN)
+    logging.basicConfig(level=logging.INFO)
 
     # Run the worker
     with concurrent.futures.ThreadPoolExecutor(max_workers=100) as activity_executor:
@@ -60,7 +64,9 @@ async def main():
                 activities.agent_validatePrompt,
                 activities.agent_toolPlanner,
                 activities.get_wf_env_vars,
+                activities.mcp_tool_activity,
                 dynamic_tool_activity,
+                mcp_list_tools,
             ],
             activity_executor=activity_executor,
         )
diff --git a/tests/workflowtests/agent_goal_workflow_test.py b/tests/workflowtests/agent_goal_workflow_test.py
index 81d67fa..552611b 100644
--- a/tests/workflowtests/agent_goal_workflow_test.py
+++ b/tests/workflowtests/agent_goal_workflow_test.py
@@ -1,9 +1,11 @@
 import concurrent.futures
 import uuid
 from contextlib import contextmanager
+from typing import Any, Dict, List, Optional, Sequence
 
 from temporalio import activity
 from temporalio.client import Client, WorkflowExecutionStatus
+from temporalio.common import RawValue
 from temporalio.worker import Worker
 
 from api.main import get_initial_agent_goal
@@ -16,6 +18,7 @@ from models.data_types import (
     ValidationInput,
     ValidationResult,
 )
+from models.tool_definitions import MCPServerDefinition
 from workflows.agent_goal_workflow import AgentGoalWorkflow
 
 
@@ -53,6 +56,20 @@ async def test_flight_booking(client: Client):
         async def mock_agent_toolPlanner(input: ToolPromptInput) -> dict:
             return {"next": "done", "response": "Test response from LLM"}
 
+        @activity.defn(name="mcp_list_tools")
+        async def mock_mcp_list_tools(
+            server_definition: MCPServerDefinition, include_tools: Optional[List[str]] = None
+        ) -> Dict[str, Any]:
+            return {"success": True, "tools": {}, "server_name": "test"}
+
+        @activity.defn(name="mcp_tool_activity")
+        async def mock_mcp_tool_activity(tool_name: str, tool_args: Dict[str, Any]) -> Dict[str, Any]:
+            return {"success": True, "result": "Mock MCP tool result"}
+
+        @activity.defn(name="dynamic_tool_activity", dynamic=True)
+        async def mock_dynamic_tool_activity(args: Sequence[RawValue]) -> dict:
+            return {"success": True, "result": "Mock dynamic tool result"}
+
         with concurrent.futures.ThreadPoolExecutor(
             max_workers=100
         ) as activity_executor:
@@ -64,6 +81,9 @@ async def test_flight_booking(client: Client):
                     mock_get_wf_env_vars,
                     mock_agent_validatePrompt,
                     mock_agent_toolPlanner,
+                    mock_mcp_list_tools,
+                    mock_mcp_tool_activity,
+                    mock_dynamic_tool_activity,
                 ],
                 activity_executor=activity_executor,
             )
diff --git a/todo.md b/todo.md
index 10d7663..dbba1da 100644
--- a/todo.md
+++ b/todo.md
@@ -2,8 +2,6 @@
 
 ## General Agent Enhancements
 
-[ ] MCP: There is a plan to add MCP (Model Context Protocol) to the agent. This really really really needs to be done and is scheduled to be done by @steveandroulakis some time in June 2025.
-
 [ ] Google's A2A is emerging as the standard way to hand off agents to other agents. We should examine implementing this soon.
 
 [ ] Custom metrics/tracing is important for AI specific aspects such as number of LLM calls, number of bad LLM responses that require retrying, number of bad chat outcomes. We should add this.
diff --git a/tools/__init__.py b/tools/__init__.py
index fff0caa..9d8a115 100644
--- a/tools/__init__.py
+++ b/tools/__init__.py
@@ -8,6 +8,7 @@ from .fin.get_account_balances import get_account_balance
 from .fin.move_money import move_money
 from .fin.submit_loan_application import submit_loan_application
 from .find_events import find_events
+from .food.add_to_cart import add_to_cart
 from .give_hint import give_hint
 from .guess_location import guess_location
 from .hr.book_pto import book_pto
@@ -66,5 +67,7 @@ def get_handler(tool_name: str):
         return give_hint
     if tool_name == "GuessLocation":
         return guess_location
+    if tool_name == "AddToCart":
+        return add_to_cart
 
     raise ValueError(f"Unknown tool: {tool_name}")
diff --git a/tools/create_invoice.py b/tools/create_invoice.py
index 7d40f62..0c26043 100644
--- a/tools/create_invoice.py
+++ b/tools/create_invoice.py
@@ -1,17 +1,13 @@
 import os
-
-import stripe
 from dotenv import load_dotenv
 
-load_dotenv(override=True)  # Load environment variables from a .env file
-
-stripe.api_key = os.getenv("STRIPE_API_KEY")
-
 
 def ensure_customer_exists(
     customer_id: str = None, email: str = "default@example.com"
 ) -> str:
     """Ensure a Stripe customer exists; create one if not."""
+    import stripe
+    
     if customer_id:
         try:
             stripe.Customer.retrieve(customer_id)
@@ -27,6 +23,12 @@ def ensure_customer_exists(
 
 def create_invoice(args: dict) -> dict:
     """Create and finalize a Stripe invoice."""
+    import stripe
+    
+    # Load environment variables and configure stripe
+    load_dotenv(override=True)
+    stripe.api_key = os.getenv("STRIPE_API_KEY")
+    
     # If an API key exists in the env file, find or create customer
     if stripe.api_key is not None and stripe.api_key != "":
         customer_id = ensure_customer_exists(
diff --git a/tools/food/add_to_cart.py b/tools/food/add_to_cart.py
new file mode 100644
index 0000000..500b152
--- /dev/null
+++ b/tools/food/add_to_cart.py
@@ -0,0 +1,33 @@
+def add_to_cart(args: dict) -> dict:
+    """
+    Simple stateless cart tool for demo purposes.
+    In production, this would use proper session storage or database.
+    """
+    customer_email = args.get("customer_email")
+    item_name = args.get("item_name")
+    item_price = float(args.get("item_price", 0))
+    quantity = int(args.get("quantity", 1))
+    stripe_product_id = args.get("stripe_product_id")
+    
+    # Basic validation
+    if not customer_email:
+        return {"error": "Customer email is required"}
+    if not item_name:
+        return {"error": "Item name is required"}
+    if item_price <= 0:
+        return {"error": "Item price must be greater than 0"}
+    if quantity <= 0:
+        return {"error": "Quantity must be greater than 0"}
+    
+    # For demo purposes, just acknowledge the addition
+    # In a real system, this would store to session/database
+    return {
+        "status": "success",
+        "message": f"Added {quantity} x {item_name} (${item_price}) to cart for {customer_email}",
+        "item_added": {
+            "name": item_name,
+            "price": item_price,
+            "quantity": quantity,
+            "stripe_product_id": stripe_product_id
+        }
+    }
\ No newline at end of file
diff --git a/tools/goal_registry.py b/tools/goal_registry.py
index 5f93dc1..3d34575 100644
--- a/tools/goal_registry.py
+++ b/tools/goal_registry.py
@@ -2,7 +2,7 @@ import os
 from typing import List
 
 import tools.tool_registry as tool_registry
-from models.tool_definitions import AgentGoal
+from models.tool_definitions import AgentGoal, MCPServerDefinition
 
 # Turn on Silly Mode - this should be a description of the persona you'd like the bot to have and can be a single word or a phrase.
 # Example if you want the bot to be a specific person, like Mario or Christopher Walken, or to describe a specific tone:
@@ -455,6 +455,126 @@ goal_ecomm_list_orders = AgentGoal(
     ),
 )
 
+
+# ----- MCP Integrations -----
+goal_mcp_stripe = AgentGoal(
+    id="goal_mcp_stripe",
+    category_tag="mcp-integrations",
+    agent_name="Stripe MCP Agent",
+    agent_friendly_description="Manage Stripe operations via MCP",
+    tools=[],  # Will be populated dynamically
+    mcp_server_definition=MCPServerDefinition(
+        name="stripe-mcp",
+        command="npx",
+        args=[
+            "-y",
+            "@stripe/mcp",
+            "--tools=all",
+            f"--api-key={os.getenv('STRIPE_API_KEY')}",
+        ],
+        env=None,
+        included_tools=["list_customers", "list_products"],
+    ),
+    description="Help manage Stripe operations for customer and product data by using the customers.read and products.read tools.",
+    starter_prompt="Welcome! I can help you read Stripe customer and product information.",
+    example_conversation_history="\n ".join(
+        [
+            "agent: Welcome! I can help you read Stripe customer and product information. What would you like to do first?",
+            "user: what customers are there?",
+            "agent: I'll check for customers now.",
+            "user_confirmed_tool_run: <user clicks confirm on customers.read tool>",
+            'tool_result: { "customers": [{"id": "cus_abc", "name": "Customer A"}, {"id": "cus_xyz", "name": "Customer B"}] }',
+            "agent: I found two customers: Customer A and Customer B. Can I help with anything else?",
+            "user: what products exist?",
+            "agent: Let me get the list of products for you.",
+            "user_confirmed_tool_run: <user clicks confirm on products.read tool>",
+            'tool_result: { "products": [{"id": "prod_123", "name": "Gold Plan"}, {"id": "prod_456", "name": "Silver Plan"}] }',
+            "agent: I found two products: Gold Plan and Silver Plan.",
+        ]
+    ),
+)
+
+# ----- Food Ordering Goal -----
+goal_food_ordering = AgentGoal(
+    id="goal_food_ordering",
+    category_tag="food",
+    agent_name="Food Ordering Assistant",
+    agent_friendly_description="Order food from Tony's Pizza Palace using Stripe for payment processing. Browse menu, add items to your order, and check out securely. Please ensure context carries over between tool runs.",
+    tools=[tool_registry.food_add_to_cart_tool],
+    mcp_server_definition=MCPServerDefinition(
+        name="stripe-mcp",
+        command="npx",
+        args=[
+            "-y",
+            "@stripe/mcp",
+            "--tools=all",
+            f"--api-key={os.getenv('STRIPE_API_KEY')}",
+        ],
+        env=None,
+        included_tools=[
+            "list_products",
+            "list_prices",
+            "create_customer",
+            "create_invoice",
+            "create_invoice_item",
+            "finalize_invoice",
+        ],
+    ),
+    description="The user wants to order food from Tony's Pizza Palace. "
+    "First, help the user browse the menu by calling list_products. "
+    "When they express interest in items, get pricing using list_prices. "
+    "Add items to their cart using AddToCart as they decide - the order doesn't matter, multiple items can be added. "
+    "After they're done selecting items, get their customer details and create a Stripe customer. "
+    "For checkout: 1) create_invoice, 2) create_invoice_item for each individual item (IMPORTANT: create_invoice_item does NOT accept quantity parameter - call it once per item, so if user wants 2 pizzas, call create_invoice_item twice with the same price), "
+    "3) finalize_invoice. The finalized invoice will contain a hosted_invoice_url for payment.",
+    starter_prompt=starter_prompt_generic,
+    example_conversation_history="\n ".join(
+        [
+            "user: I want to order food.",
+            "agent: Welcome to Tony's Pizza Palace! I can help you browse our menu, add items to your cart, and process payment. Let me show you what we have available.",
+            "user_confirmed_tool_run: <user clicks confirm on list_products tool with limit=100 and product.metadata.use_case == 'food_ordering_demo'>",
+            'tool_result: {"products": [{"id": "prod_pepperoni", "name": "Pepperoni Pizza", "description": "A timeless classic featuring pepperoni"}, {"id": "prod_margherita", "name": "Margherita Pizza", "description": "Fresh mozzarella and basil"}, {"id": "prod_garlic_bread", "name": "Garlic Bread", "description": "Warm crusty bread with garlic butter"}, {"id": "prod_soda", "name": "Soda", "description": "A large bottle of cola"}]}',
+            "agent: We have Pepperoni Pizza, Margherita Pizza, Garlic Bread, and Soda available. What would you like to order?",
+            "user: I'd like 2 pepperoni pizzas and a soda.",
+            "agent: Excellent! Let me get the pricing for the pepperoni pizzas first so you know the cost.",
+            "user_confirmed_tool_run: <user clicks confirm on list_prices tool with product='prod_pepperoni'>",
+            'tool_result: {"prices": [{"id": "price_pepperoni_large", "product": "prod_pepperoni", "unit_amount": 2299, "currency": "usd"}]}',
+            "agent: Pepperoni Pizza is $22.99 each. Now let me check the soda pricing:",
+            "user_confirmed_tool_run: <user clicks confirm on list_prices tool with product='prod_soda'>",
+            'tool_result: {"prices": [{"id": "price_soda", "product": "prod_soda", "unit_amount": 250, "currency": "usd"}]}',
+            "agent: And Soda is $2.50. So 2 Pepperoni Pizzas ($22.99 each) plus 1 Soda ($2.50) = $48.48 total. What's your email address to add these items to your cart?",
+            "user: jane.smith@example.com",
+            "agent: Perfect! Adding 2 Pepperoni Pizzas to your cart for jane.smith@example.com. Note: I'm using quantity=2 since you want 2 pizzas.",
+            "user_confirmed_tool_run: <user clicks confirm on AddToCart tool with customer_email='jane.smith@example.com', item_name='Pepperoni Pizza', item_price=22.99, quantity=2, stripe_product_id='prod_pepperoni'>",
+            'tool_result: {"status": "success", "message": "Added 2 x Pepperoni Pizza ($22.99) to cart for jane.smith@example.com", "item_added": {"quantity": 2, "name": "Pepperoni Pizza"}}',
+            "agent: Great! Added 2 Pepperoni Pizzas to your cart. Now adding the Soda (quantity=1):",
+            "user_confirmed_tool_run: <user clicks confirm on AddToCart tool with customer_email='jane.smith@example.com', item_name='Soda', item_price=2.50, quantity=1, stripe_product_id='prod_soda'>",
+            'tool_result: {"status": "success", "message": "Added 1 x Soda ($2.50) to cart for jane.smith@example.com", "item_added": {"quantity": 1, "name": "Soda"}}',
+            "agent: Excellent! Your cart now contains: 2 Pepperoni Pizzas ($22.99 each) and 1 Soda ($2.50). Ready to checkout? I'll need your full name.",
+            "user: Yes, let's proceed with payment. My name is Jane Smith.",
+            "agent: Thank you Jane! Creating your Stripe customer profile with name and email.",
+            "user_confirmed_tool_run: <user clicks confirm on create_customer tool with name='Jane Smith' and email='jane.smith@example.com'>",
+            'tool_result: {"customer": {"id": "cus_ExAmPlE12345", "name": "Jane Smith", "email": "jane.smith@example.com"}}',
+            "agent: Customer profile created! Now I'll create a draft invoice for your order.",
+            "user_confirmed_tool_run: <user clicks confirm on create_invoice tool with customer='cus_ExAmPlE12345'>",
+            'tool_result: {"invoice": {"id": "in_InvOicE54321", "status": "draft", "customer": "cus_ExAmPlE12345"}}',
+            "agent: Invoice created! Now adding your first Pepperoni Pizza to the invoice.",
+            "user_confirmed_tool_run: <user clicks confirm on create_invoice_item tool with customer='cus_ExAmPlE12345', invoice='in_InvOicE54321', price='price_pepperoni_large'>",
+            'tool_result: {"status": "success", "invoice_item": {"id": "ii_pizza1"}}',
+            "agent: First pizza added! Now adding your second Pepperoni Pizza to the invoice.",
+            "user_confirmed_tool_run: <user clicks confirm on create_invoice_item tool with customer='cus_ExAmPlE12345', invoice='in_InvOicE54321', price='price_pepperoni_large'>",
+            'tool_result: {"status": "success", "invoice_item": {"id": "ii_pizza2"}}',
+            "agent: Both pizzas added! Now adding your Soda to the invoice.",
+            "user_confirmed_tool_run: <user clicks confirm on create_invoice_item tool with customer='cus_ExAmPlE12345', invoice='in_InvOicE54321', price='price_soda'>",
+            'tool_result: {"status": "success", "invoice_item": {"id": "ii_soda"}}',
+            "agent: All items added to invoice! Now finalizing to generate the payment link.",
+            "user_confirmed_tool_run: <user clicks confirm on finalize_invoice tool with invoice='in_InvOicE54321'>",
+            'tool_result: {"invoice": {"id": "in_InvOicE54321", "status": "open", "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1NBOLuKVZbzw7QA5/test_YWNjdF8xTkJPTHVLVlpienc3UUE1LF9SbGJlZ2xLMjhlc3lxNzFkVVBXbkswOUlFa2Rna1RxLDEzMDAwMTY4Nw0200RKeJRMlw?s=ap", "amount_due": 4848}}',
+            "agent: Perfect! Your order is complete with 2 Pepperoni Pizzas and 1 Soda. Total: $48.48. Pay securely here: https://invoice.stripe.com/i/acct_1NBOLuKVZbzw7QA5/test_YWNjdF8xTkJPTHVLVlpienc3UUE1LF9SbGJlZ2xLMjhlc3lxNzFkVVBXbkswOUlFa2Rna1RxLDEzMDAwMTY4Nw0200RKeJRMlw?s=ap\\n\\nThank you for ordering from Tony's Pizza Palace!",
+        ]
+    ),
+)
+
 # Add the goals to a list for more generic processing, like listing available agents
 goal_list: List[AgentGoal] = []
 goal_list.append(goal_choose_agent_type)
@@ -469,6 +589,8 @@ goal_list.append(goal_fin_move_money)
 goal_list.append(goal_fin_loan_application)
 goal_list.append(goal_ecomm_list_orders)
 goal_list.append(goal_ecomm_order_status)
+goal_list.append(goal_mcp_stripe)
+goal_list.append(goal_food_ordering)
 
 
 # for multi-goal, just set list agents as the last tool
diff --git a/tools/list_agents.py b/tools/list_agents.py
index d80955e..719c2c5 100644
--- a/tools/list_agents.py
+++ b/tools/list_agents.py
@@ -1,6 +1,6 @@
 import os
 
-import tools.goal_registry as goals
+import goals
 
 
 def list_agents(args: dict) -> dict:
diff --git a/tools/tool_registry.py b/tools/tool_registry.py
index bb9f6d8..478c431 100644
--- a/tools/tool_registry.py
+++ b/tools/tool_registry.py
@@ -1,3 +1,5 @@
+from typing import Dict, List
+
 from models.tool_definitions import ToolArgument, ToolDefinition
 
 # ----- System tools -----
@@ -397,3 +399,75 @@ ecomm_track_package = ToolDefinition(
         ),
     ],
 )
+
+
+# ----- Food Ordering Use Case Tools -----
+food_add_to_cart_tool = ToolDefinition(
+    name="AddToCart",
+    description="Add a menu item to the customer's cart using item details from Stripe.",
+    arguments=[
+        ToolArgument(
+            name="customer_email",
+            type="string",
+            description="Email address of the customer",
+        ),
+        ToolArgument(
+            name="item_name",
+            type="string",
+            description="Name of the menu item (e.g., 'Margherita Pizza', 'Caesar Salad')",
+        ),
+        ToolArgument(
+            name="item_price",
+            type="number",
+            description="Price of the item in dollars (e.g., 14.99)",
+        ),
+        ToolArgument(
+            name="quantity",
+            type="number",
+            description="Quantity of the item to add (defaults to 1)",
+        ),
+        ToolArgument(
+            name="stripe_product_id",
+            type="string",
+            description="Stripe product ID for reference (optional)",
+        ),
+    ],
+)
+
+# MCP Integration Functions
+
+
+def create_mcp_tool_definitions(
+    mcp_tools_info: Dict[str, Dict],
+) -> List[ToolDefinition]:
+    """Convert MCP tool info to ToolDefinition objects"""
+    tool_definitions = []
+
+    for tool_name, tool_info in mcp_tools_info.items():
+        # Extract input schema properties
+        input_schema = tool_info.get("inputSchema", {})
+        properties = (
+            input_schema.get("properties", {}) if isinstance(input_schema, dict) else {}
+        )
+
+        # Convert properties to ToolArgument objects
+        arguments = []
+        for param_name, param_info in properties.items():
+            if isinstance(param_info, dict):
+                arguments.append(
+                    ToolArgument(
+                        name=param_name,
+                        type=param_info.get("type", "string"),
+                        description=param_info.get("description", ""),
+                    )
+                )
+
+        # Create ToolDefinition
+        tool_def = ToolDefinition(
+            name=tool_info["name"],
+            description=tool_info.get("description", ""),
+            arguments=arguments,
+        )
+        tool_definitions.append(tool_def)
+
+    return tool_definitions
diff --git a/workflows/agent_goal_workflow.py b/workflows/agent_goal_workflow.py
index dda2e55..bafdee9 100644
--- a/workflows/agent_goal_workflow.py
+++ b/workflows/agent_goal_workflow.py
@@ -20,10 +20,11 @@ from workflows.workflow_helpers import (
 )
 
 with workflow.unsafe.imports_passed_through():
-    from activities.tool_activities import ToolActivities
+    from activities.tool_activities import ToolActivities, mcp_list_tools
     from models.data_types import CombinedInput, ToolPromptInput
     from prompts.agent_prompt_generators import generate_genai_prompt
-    from tools.goal_registry import goal_list
+    from goals import goal_list
+    from tools.tool_registry import create_mcp_tool_definitions
 
 # Constants
 MAX_TURNS_BEFORE_CONTINUE = 250
@@ -59,6 +60,7 @@ class AgentGoalWorkflow:
         self.multi_goal_mode: bool = (
             False  # set from env file in activity lookup_wf_env_settings
         )
+        self.mcp_tools_info: Optional[dict] = None  # stores complete MCP tools result
 
     # see ../api/main.py#temporal_client.start_workflow() for how the input parameters are set
     @workflow.run
@@ -70,6 +72,10 @@ class AgentGoalWorkflow:
 
         await self.lookup_wf_env_settings(combined_input)
 
+        # If the goal has an MCP server definition, dynamically load MCP tools
+        if self.goal.mcp_server_definition:
+            await self.load_mcp_tools()
+
         # add message from sample conversation provided in tools/goal_registry.py, if it exists
         if params and params.conversation_summary:
             self.add_message("conversation_summary", params.conversation_summary)
@@ -146,6 +152,7 @@ class AgentGoalWorkflow:
                     conversation_history=self.conversation_history,
                     multi_goal_mode=self.multi_goal_mode,
                     raw_json=self.tool_data,
+                    mcp_tools_info=self.mcp_tools_info,
                 )
 
                 prompt_input = ToolPromptInput(
@@ -368,6 +375,7 @@ class AgentGoalWorkflow:
             self.tool_results,
             self.add_message,
             self.prompt_queue,
+            self.goal,
         )
 
         # set new goal if we should
@@ -398,3 +406,43 @@ class AgentGoalWorkflow:
         else:
             print("no tool data initialized yet")
         print(f"self.confirmed: {self.confirmed}")
+
+    async def load_mcp_tools(self) -> None:
+        """Load MCP tools dynamically from the server definition"""
+        if not self.goal.mcp_server_definition:
+            return
+
+        workflow.logger.info(
+            f"Loading MCP tools from server: {self.goal.mcp_server_definition.name}"
+        )
+
+        # Get the list of tools to include (if specified)
+        include_tools = self.goal.mcp_server_definition.included_tools
+
+        # Call the MCP list tools activity
+        mcp_tools_result = await workflow.execute_activity(
+            mcp_list_tools,
+            args=[self.goal.mcp_server_definition, include_tools],
+            start_to_close_timeout=LLM_ACTIVITY_START_TO_CLOSE_TIMEOUT,
+            retry_policy=RetryPolicy(
+                initial_interval=timedelta(seconds=5), backoff_coefficient=1
+            ),
+            summary=f"{self.goal.mcp_server_definition.name}",
+        )
+
+        if mcp_tools_result.get("success", False):
+            tools_info = mcp_tools_result.get("tools", {})
+            workflow.logger.info(f"Successfully loaded {len(tools_info)} MCP tools")
+
+            # Store complete MCP tools result for use in prompt generation
+            self.mcp_tools_info = mcp_tools_result
+
+            # Convert MCP tools to ToolDefinition objects and add to goal
+            mcp_tool_definitions = create_mcp_tool_definitions(tools_info)
+            self.goal.tools.extend(mcp_tool_definitions)
+
+            workflow.logger.info(f"Added {len(mcp_tool_definitions)} MCP tools to goal")
+        else:
+            error_msg = mcp_tools_result.get("error", "Unknown error")
+            workflow.logger.error(f"Failed to load MCP tools: {error_msg}")
+            # Continue execution without MCP tools
diff --git a/workflows/workflow_helpers.py b/workflows/workflow_helpers.py
index 24009d8..28c1bf1 100644
--- a/workflows/workflow_helpers.py
+++ b/workflows/workflow_helpers.py
@@ -6,6 +6,7 @@ from temporalio.common import RetryPolicy
 from temporalio.exceptions import ActivityError
 
 from models.data_types import ConversationHistory, ToolPromptInput
+from models.tool_definitions import AgentGoal
 from prompts.agent_prompt_generators import (
     generate_missing_args_prompt,
     generate_tool_completion_prompt,
@@ -19,35 +20,118 @@ LLM_ACTIVITY_START_TO_CLOSE_TIMEOUT = timedelta(seconds=20)
 LLM_ACTIVITY_SCHEDULE_TO_CLOSE_TIMEOUT = timedelta(minutes=30)
 
 
+def is_mcp_tool(tool_name: str, goal: AgentGoal) -> bool:
+    """Check if a tool is an MCP tool based on the goal's MCP server definition"""
+    if not goal.mcp_server_definition:
+        return False
+
+    # Check if the tool name matches any MCP tools that were loaded
+    # We can identify MCP tools by checking if they're not in the original static tools
+    from tools.tool_registry import (
+        book_pto_tool,
+        book_trains_tool,
+        change_goal_tool,
+        create_invoice_tool,
+        current_pto_tool,
+        ecomm_get_order,
+        ecomm_list_orders,
+        ecomm_track_package,
+        financial_check_account_is_valid,
+        financial_get_account_balances,
+        financial_move_money,
+        financial_submit_loan_approval,
+        find_events_tool,
+        food_add_to_cart_tool,
+        future_pto_calc_tool,
+        give_hint_tool,
+        guess_location_tool,
+        list_agents_tool,
+        paycheck_bank_integration_status_check,
+        search_fixtures_tool,
+        search_flights_tool,
+        search_trains_tool,
+    )
+
+    static_tool_names = {
+        list_agents_tool.name,
+        change_goal_tool.name,
+        give_hint_tool.name,
+        guess_location_tool.name,
+        search_flights_tool.name,
+        search_trains_tool.name,
+        book_trains_tool.name,
+        create_invoice_tool.name,
+        search_fixtures_tool.name,
+        find_events_tool.name,
+        current_pto_tool.name,
+        future_pto_calc_tool.name,
+        book_pto_tool.name,
+        paycheck_bank_integration_status_check.name,
+        financial_check_account_is_valid.name,
+        financial_get_account_balances.name,
+        financial_move_money.name,
+        financial_submit_loan_approval.name,
+        ecomm_list_orders.name,
+        ecomm_get_order.name,
+        ecomm_track_package.name,
+        food_add_to_cart_tool.name,
+    }
+
+    return tool_name not in static_tool_names
+
+
 async def handle_tool_execution(
     current_tool: str,
     tool_data: Dict[str, Any],
     tool_results: list,
     add_message_callback: callable,
     prompt_queue: Deque[str],
+    goal: AgentGoal = None,
 ) -> None:
     """Execute a tool after confirmation and handle its result."""
     workflow.logger.info(f"Confirmed. Proceeding with tool: {current_tool}")
 
-    task_queue = (
-        TEMPORAL_LEGACY_TASK_QUEUE
-        if current_tool in ["SearchTrains", "BookTrains"]
-        else None
-    )
-
     try:
-        dynamic_result = await workflow.execute_activity(
-            current_tool,
-            tool_data["args"],
-            task_queue=task_queue,
-            schedule_to_close_timeout=TOOL_ACTIVITY_SCHEDULE_TO_CLOSE_TIMEOUT,
-            start_to_close_timeout=TOOL_ACTIVITY_START_TO_CLOSE_TIMEOUT,
-            retry_policy=RetryPolicy(
-                initial_interval=timedelta(seconds=5), backoff_coefficient=1
-            ),
-        )
+        # Check if this is an MCP tool
+        if goal and is_mcp_tool(current_tool, goal):
+            workflow.logger.info(f"Executing MCP tool: {current_tool}")
+
+            # Add server definition to args for MCP tools
+            mcp_args = tool_data["args"].copy()
+            mcp_args["server_definition"] = goal.mcp_server_definition
+
+            dynamic_result = await workflow.execute_activity(
+                current_tool,
+                mcp_args,
+                schedule_to_close_timeout=TOOL_ACTIVITY_SCHEDULE_TO_CLOSE_TIMEOUT,
+                start_to_close_timeout=TOOL_ACTIVITY_START_TO_CLOSE_TIMEOUT,
+                retry_policy=RetryPolicy(
+                    initial_interval=timedelta(seconds=5), backoff_coefficient=1
+                ),
+                summary=f"{goal.mcp_server_definition.name} (MCP Tool)",
+            )
+        else:
+            # Handle regular tools
+            task_queue = (
+                TEMPORAL_LEGACY_TASK_QUEUE
+                if current_tool in ["SearchTrains", "BookTrains"]
+                else None
+            )
+
+            dynamic_result = await workflow.execute_activity(
+                current_tool,
+                tool_data["args"],
+                task_queue=task_queue,
+                schedule_to_close_timeout=TOOL_ACTIVITY_SCHEDULE_TO_CLOSE_TIMEOUT,
+                start_to_close_timeout=TOOL_ACTIVITY_START_TO_CLOSE_TIMEOUT,
+                retry_policy=RetryPolicy(
+                    initial_interval=timedelta(seconds=5), backoff_coefficient=1
+                ),
+            )
+
         dynamic_result["tool"] = current_tool
         tool_results.append(dynamic_result)
+
     except ActivityError as e:
         workflow.logger.error(f"Tool execution failed: {str(e)}")
         dynamic_result = {"error": str(e), "tool": current_tool}
